#!/bin/bash

#
# TODO:
#
# - Generate a report about missing build deps of board packages in
#   sdk. These reports can be generated by processing sdk-pkgs-kv and
#   board-bdeps reports, I think.
#
# - Mount Gentoo repo into the SDK container and set up emerge to use
#   Gentoo as a primary repo, and portage-stable and coreos-overlay as
#   overlays. That way if an updated package pulls in a new package we
#   can notice it when it comes from Gentoo (emerge reports also
#   source repo like sys-libs/glibc-2.35-r5::gentoo or something like
#   this). This would make this script more robust.
#

source "$(dirname "${BASH_SOURCE[0]}")/stuff.sh"

# Needed to be enabled here to parse some globs inside the functions.
shopt -s extglob
# Saner defaults.
shopt -s nullglob
shopt -s dotglob

# TODO: docs
function debug_new_state() {
    local arch
    arch=${1}; shift

    local image_var_name
    image_var_name="${arch^^}_PACKAGES_IMAGE"
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    # shellcheck disable=SC2153 # NEW_STATE is not a misspelling, comes from globals
    add_cleanup "rm -f ${NEW_STATE@Q}/{print_profile_tree.sh,inside_sdk_container.sh,stuff.sh}"
    cp -a "${PKG_AUTO_DIR}"/{print_profile_tree.sh,inside_sdk_container.sh,stuff.sh} "${NEW_STATE}"
    add_cleanup "git -C ${NEW_STATE@Q} checkout -- sdk_container/.repo/manifests/version.txt"
    env --chdir "${NEW_STATE}" \
        ./run_sdk_container \
        -t \
        -C "${!image_var_name}" \
        -n "pkg-new-state-debug-${arch}" \
        -a "${arch}" \
        --rm || :
}

function create_dir_for_workdir() {
    local prefix path_var_name
    prefix=${1}; shift
    path_var_name=${1}; shift
    local -n path_ref="${path_var_name}"

    if [[ -z "${path_ref:-}" ]]; then
        path_ref=$(mktemp --tmpdir --directory "${prefix}.XXXXXXXX")
    else
        mkdir -p "${path_ref}"
    fi
}

function get_state_refs() {
    local workdir old_state_ref_var_name new_state_ref_var_name
    workdir=${1}; shift
    old_state_ref_var_name=${1}; shift
    local -n old_state_ref_ref="${old_state_ref_var_name}"
    new_state_ref_var_name=${1}; shift
    local -n new_state_ref_ref="${new_state_ref_var_name}"

    # shellcheck disable=SC2034 # ref to an external variable
    old_state_ref_ref=$(git -C "${WORKDIR}/old_state" rev-parse --abbrev-ref HEAD)
    # shellcheck disable=SC2034 # ref to an external variable
    new_state_ref_ref=$(git -C "${WORKDIR}/new_state" rev-parse --abbrev-ref HEAD)
}

function get_workdir_config_opts() {
    # all opts are key value-var-name pairs

    get_config_opts "${WORKDIR}/config" "${@}"
}

function get_config_opts() {
    local config_file
    config_file=${1}; shift
    # rest are key value-var-name pairs

    local -A mapping
    mapping=()
    local key var_name
    while [[ ${#} -gt 1 ]]; do
        key=${1}; shift
        var_name=${1}; shift
        mapping["${key}"]=${var_name}
    done

    local line value gwco_stripped
    while read -r line; do
        strip_out "${line%%:*}" gwco_stripped
        key=${gwco_stripped}
        var_name=${mapping["${key}"]:-}
        if [[ -n "${var_name}" ]]; then
            strip_out "${line#*:}" "${var_name}"
        fi
    done < <(cat_meaningful "${config_file}")
}

function setup_workdir_with_config() {
    local workdir file
    workdir=${1}; shift
    file=${1}; shift

    local cfg_scripts cfg_aux cfg_reports cfg_old_base cfg_new_base
    local cfg_cleanups_kind
    local -a cfg_cleanups_opts
    local -A cfg_overrides

    # some defaults
    cfg_old_base='origin/main'
    cfg_new_base=''
    cfg_cleanups_opts=('ignore')
    cfg_overrides=()

    local line key value swwc_stripped var_name arch
    while read -r line; do
        strip_out "${line%%:*}" swwc_stripped
        key=${swwc_stripped}
        strip_out "${line#*:}" swwc_stripped
        value=${swwc_stripped}
        ensure_not_empty "${key}" "${value}"
        case ${key} in
            scripts|aux|reports)
                var_name="cfg_${key//-/_}"
                local -n var="${var_name}"
                var=$(realpath "${value}")
                unset -n var
                ;;
            old-base|new-base)
                var_name="cfg_${key//-/_}"
                local -n var="${var_name}"
                var=${value}
                unset -n var
                ;;
            cleanups)
                mapfile -t -d';' cfg_cleanups_opts < <(printf '%s' "${value}")
                ;;
            *-sdk-img)
                arch=${key%%-*}
                # shellcheck disable=SC2034 # used by name below
                cfg_overrides["${arch}"]=${value}
                ;;
        esac
    done < <(cat_meaningful "${file}")
    if [[ -z "${cfg_new_base}" ]]; then
        cfg_new_base=${cfg_old_base}
    fi
    for key in scripts aux reports; do
        var_name="cfg_${key//-/_}"
        ensure_specified "${key}" "${!var_name}"
    done

    setup_cleanups "${cfg_cleanups_opts[@]}"
    setup_workdir "${workdir}"
    add_cleanup "rm -f ${WORKDIR@Q}/config"
    cp -a "${config_file}" "${WORKDIR}/config"
    setup_worktrees_in_workdir "${cfg_scripts}" "${cfg_old_base}" "${cfg_new_base}" "${cfg_reports}" "${cfg_aux}"
    override_sdk_image_names cfg_overrides
}

function strip_out() {
    local l out_var_name
    l=${1}; shift
    out_var_name=${1}; shift
    local -n out_ref="${out_var_name}"

    local t
    t=${l}
    t=${t/#+([[:space:]])}
    t=${t/%+([[:space:]])}
    out_ref=${t}
}

function ensure_not_empty() {
    local key value
    key=${1}; shift
    value=${1}; shift

    fail_if_empty "${value}" "empty value for ${key} in config"
}

function ensure_specified() {
    local key value
    key=${1}; shift
    value=${1}; shift

    fail_if_empty "${value}" "${key} was not specified in config"
}

function fail_if_empty() {
    local value message
    value=${1}; shift
    message=${1}; shift
    if [[ -z ${value} ]]; then
        fail "${message}"
    fi
}

function setup_workdir_with_tmp_config() {
    local workdir=${1}; shift
    local tmp_config=${1}; shift

    local rv
    rv=0
    setup_workdir_with_config "${workdir}" "${tmp_config}" || rv=${?}
    rm -f "${tmp_config}"
    if [[ ${rv} -ne 0 ]]; then
        fail "setting up worktree failed with exit status ${rv}"
    fi
}

# Takes an existing directory as a workdir. Usable only if workdir was
# prepared for resumption, which happens when generating reports from
# SDK fails.
function resume_workdir_from() {
    local workdir
    workdir=${1}; shift

    if [[ ! -e "${workdir}/cleanup-stash-file" ]]; then
        fail 'no cleanup stash file in workdir, was the directory prepared for resumption?'
    fi
    resume_cleanups "${workdir}/cleanup-stash-file"

    set_workdir_to "${workdir}"
}

function set_workdir_to() {
    declare -g WORKDIR
    WORKDIR=$(realpath "${1}")
}

# Goes over the list of automatically updated packages and synces them
# with packages from Gentoo repo. Cleans up missing packages.
function perform_sync_with_gentoo() {
    local gentoo
    gentoo=$(realpath "${1}"); shift

    run_sync "${gentoo}"
    handle_missing_in_scripts
    handle_missing_in_gentoo "${gentoo}"
}

# TODO: docs
function generate_package_update_reports() {
    generate_sdk_reports
    handle_gentoo_sync
}

# Saves the new state to a save branch in scripts.
function save_new_state() {
    local branch_name
    branch_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"
    info "saving new state to branch ${branch_name}"
    # shellcheck disable=SC2153 # SCRIPTS is not a misspelling, it comes from globals file
    git -C "${SCRIPTS}" branch --force "${branch_name}" "${NEW_STATE_BRANCH}"
}

# TO BE SORTED BELOW

# Creates a workdir, the path to which is stored in WORKDIR global
# variable.
#
# 1 - predefined work directory path (optional)
function setup_workdir() {
    local workdir
    workdir=${1:-}
    if [[ -z "${workdir}" ]]; then
        workdir=$(mktemp --tmpdir --directory "up-XXXXXXXX")
    fi

    set_workdir_to "${workdir}"
    add_cleanup "rmdir ${WORKDIR@Q}"
    mkdir -p "${WORKDIR}"

    setup_initial_globals_file
}

function prepare_workdir_for_resumption() {
    add_cleanup "rm -f ${WORKDIR@Q}/cleanup-stash-file"
    stash_cleanups "${WORKDIR}/cleanup-stash-file"
}

# Sets up worktrees for the old and new state inside WORKDIR. Creates
# the globals file inside WORKDIR.
#
# 1 - path to scripts repo
# 2 - base for the old state worktree (e.g. origin/main)
# 3 - base for the new state worktree (e.g. origin/main)
# 4 - path to reports directory
function setup_worktrees_in_workdir() {
    local scripts old_base new_base reports_dir aux_dir
    scripts=${1}; shift
    old_base=${1}; shift
    new_base=${1}; shift
    reports_dir=${1}; shift
    aux_dir=${1}; shift

    local old_state new_state
    old_state="${WORKDIR}/old_state"
    new_state="${WORKDIR}/new_state"

    setup_worktree "${scripts}" "${old_base}" "old-state-${RANDOM}" "${old_state}"
    setup_worktree "${scripts}" "${new_base}" "new-state-${RANDOM}" "${new_state}"
    extend_globals_file "${scripts}" "${old_state}" "${new_state}" "${reports_dir}" "${aux_dir}"
}

function override_sdk_image_names() {
    local overrides_map_var_name
    overrides_map_var_name=${1}; shift
    local -n overrides_map_ref="${overrides_map_var_name}"

    local globals_file
    globals_file="${WORKDIR}/globals"
    if [[ ! -e "${globals_file}" ]]; then
        fail "globals not set yet in workdir"
    fi

    if [[ ${#overrides_map_ref[@]} -eq 0 ]]; then
        return 0
    fi

    local arch image_name upcase_arch
    local -a lines
    lines=()
    for arch in "${!overrides_map_ref[@]}"; do
        image_name=${overrides_map_ref["${arch}"]}
        upcase_arch=${arch^^}
        if [[ ${#lines[@]} -eq 0 ]]; then
            # separate overrides from initial values
            lines+=( '' )
        fi
        lines+=( "${upcase_arch@Q}_PACKAGES_IMAGE=${image_name@Q}" )
    done
    lines_to_file "${globals_file}" "${lines[@]}"
}

# TODO: docs
function save_rename_maps_simple() {
    # args are old to new name pairs
    declare -A srms_old_to_new_map srms_new_to_old_map
    srms_old_to_new_map=()
    srms_new_to_old_map=()

    local old new
    while [[ $# -gt 1 ]]; do
        old=${1}; shift
        new=${1}; shift
        # shellcheck disable=SC2034 # used by name below
        srms_old_to_new_map["${old}"]=${new}
        # shellcheck disable=SC2034 # used by name below
        srms_new_to_old_map["${new}"]=${old}
    done
    if [[ $# -gt 0 ]]; then
        fail 'odd number of parameters for saving rename maps, expected pairs only'
    fi
    save_rename_maps srms_old_to_new_map srms_new_to_old_map
}

# details

function save_rename_maps() {
    local old_to_new_map_var_name new_to_old_map_var_name
    old_to_new_map_var_name=${1}; shift
    new_to_old_map_var_name=${1}; shift
    local -n old_to_new_map_ref="${old_to_new_map_var_name}"
    local -n new_to_old_map_ref="${new_to_old_map_var_name}"

    if [[ ${#old_to_new_map_ref[@]} -eq 0 ]] && [[ ${#new_to_old_map_ref[@]} -eq 0 ]]; then
        # nothing to save
        return 0
    fi

    # shellcheck disable=SC1090 # generated file
    source "${globals_file}"

    local item mapped other_mapped
    for item in "${!old_to_new_map_ref[@]}"; do
        mapped=${old_to_new_map_ref["${item}"]}
        other_mapped=${new_to_old_map_ref["${mapped}"]:-}
        if [[ -z "${other_mapped}" ]]; then
            fail "rename maps inconsistency, missing '${mapped}' from new to old map"
        fi
    done
    for item in "${!new_to_old_map_ref[@]}"; do
        mapped=${new_to_old_map_ref["${item}"]}
        other_mapped=${old_to_new_map_ref["${mapped}"]:-}
        if [[ -z "${other_mapped}" ]]; then
            fail "rename maps inconsistency, missing '${mapped}' from new to old map"
        fi
    done

    local map_file
    # shellcheck disable=SC2153 # AUX_DIR is not a misspelling, comes from globals
    map_file="${AUX_DIR}/rename-map"
    add_cleanup "rm -f ${map_file@Q}"
    {
        for item in "${!old_to_new_map_ref[@]}"; do
            mapped=${old_to_new_map_ref["${item}"]}
            printf '%s:%s\n' "${item}" "${mapped}"
        done
    } >"${map_file}"
}

function load_rename_maps() {
    local old_to_new_map_var_name new_to_old_map_var_name
    old_to_new_map_var_name=${1}; shift
    new_to_old_map_var_name=${1}; shift
    local -n old_to_new_map_ref="${old_to_new_map_var_name}"
    local -n new_to_old_map_ref="${new_to_old_map_var_name}"

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    old_to_new_map_ref=()
    new_to_old_map_ref=()

    if [[ ! -e "${AUX_DIR}/rename-map" ]]; then
        # no rename maps, maybe there was just a simple sync
        return 0
    fi

    local old new
    while read -r line; do
        old=${line%%:*}
        new=${line##*:}
        old_to_new_map_ref["${old}"]=${new}
        new_to_old_map_ref["${new}"]=${old}
    done <"${AUX_DIR}/rename-map"
}

function setup_worktree() {
    local repo base branch worktree_dir
    repo=${1}; shift
    base=${1}; shift
    branch=${1}; shift
    worktree_dir=${1}; shift

    add_cleanup \
        "git -C ${worktree_dir@Q} reset --hard HEAD" \
        "git -C ${worktree_dir@Q} clean -ffdx" \
        "git -C ${repo@Q} worktree remove ${worktree_dir@Q}" \
        "git -C ${repo@Q} branch -D ${branch@Q}"

    git -C "${repo}" worktree add -b "${branch}" "${worktree_dir}" "${base}"
}

function setup_worktrees() {
    local scripts scripts_base old_state_branch old_state new_state_branch new_state
    scripts=${1}; shift
    scripts_base=${1}; shift
    old_state_branch=${1}; shift
    old_state=${1}; shift
    new_state_branch=${1}; shift
    new_state=${1}; shift

    add_cleanup \
        "git -C ${old_state@Q} reset --hard HEAD" \
        "git -C ${old_state@Q} clean -ffdx" \
        "git -C ${new_state@Q} reset --hard HEAD" \
        "git -C ${new_state@Q} clean -ffdx" \
        "git -C ${scripts@Q} worktree remove ${old_state@Q}" \
        "git -C ${scripts@Q} worktree remove ${new_state@Q}" \
        "git -C ${scripts@Q} branch -D ${old_state_branch@Q}" \
        "git -C ${scripts@Q} branch -D ${new_state_branch@Q}"

    git -C "${scripts}" worktree add -b "${old_state_branch}" "${old_state}" "${scripts_base}"
    git -C "${scripts}" worktree add -b "${new_state_branch}" "${new_state}" "${scripts_base}"
}

function setup_initial_globals_file() {
    local sync_script pkg_list_sort_script
    sync_script="${PKG_AUTO_DIR}/sync_with_gentoo.sh"
    pkg_list_sort_script="${PKG_AUTO_DIR}/sort_packages_list.py"

    local globals_file
    globals_file="${WORKDIR}/globals"

    local -a sigf_arches
    sigf_arches=()
    get_valid_arches sigf_arches

    add_cleanup "rm -f ${globals_file@Q}"
    cat <<EOF >"${globals_file}"
local -a GIT_ENV_VARS ARCHES WHICH REPORTS
local -A LISTING_KINDS
local SDK_PKGS BOARD_PKGS
local SYNC_SCRIPT PKG_LIST_SORT_SCRIPT

GIT_ENV_VARS=(
    GIT_{AUTHOR,COMMITTER}_{NAME,EMAIL}
)

SYNC_SCRIPT=${sync_script@Q}
PKG_LIST_SORT_SCRIPT=${pkg_list_sort_script@Q}

ARCHES=( ${sigf_arches[*]@Q} )
WHICH=('old' 'new')
SDK_PKGS='sdk-pkgs'
BOARD_PKGS='board-pkgs'
REPORTS=( "\${SDK_PKGS}" "\${BOARD_PKGS}" )

LISTING_KINDS=(
    ['prod']='flatcar_production_image_packages.txt'
    ['dev']='flatcar_developer_container_packages.txt'
)
EOF
}

function get_valid_arches() {
    local var_name
    var_name=${1}; shift
    local -n ref="${var_name}"

    # shellcheck disable=SC2034 # ref to external variable
    ref=(amd64 arm64)
}

function extend_globals_file() {
    local scripts old_state new_state reports_dir
    scripts=${1}; shift
    old_state=${1}; shift
    new_state=${1}; shift
    reports_dir=${1}; shift
    aux_dir=${1}; shift

    local globals_file
    globals_file="${WORKDIR}/globals"
    if [[ ! -e "${globals_file}" ]]; then
        fail 'an initial version of globals file should already exist'
    fi

    local old_state_branch new_state_branch
    old_state_branch=$(git -C "${old_state}" rev-parse --abbrev-ref HEAD)
    new_state_branch=$(git -C "${new_state}" rev-parse --abbrev-ref HEAD)

    local portage_stable_suffix old_portage_stable new_portage_stable
    portage_stable_suffix='sdk_container/src/third_party/portage-stable'
    old_portage_stable="${old_state}/${portage_stable_suffix}"
    new_portage_stable="${new_state}/${portage_stable_suffix}"

    cat <<EOF >>"${globals_file}"
local SCRIPTS OLD_STATE NEW_STATE OLD_STATE_BRANCH NEW_STATE_BRANCH
local PORTAGE_STABLE_SUFFIX OLD_PORTAGE_STABLE NEW_PORTAGE_STABLE REPORTS_DIR
local NEW_STATE_PACKAGES_LIST AUX_DIR

SCRIPTS=${scripts@Q}
OLD_STATE=${old_state@Q}
NEW_STATE=${new_state@Q}
OLD_STATE_BRANCH=${old_state_branch@Q}
NEW_STATE_BRANCH=${new_state_branch@Q}
PORTAGE_STABLE_SUFFIX=${portage_stable_suffix@Q}
OLD_PORTAGE_STABLE=${old_portage_stable@Q}
NEW_PORTAGE_STABLE=${new_portage_stable@Q}
REPORTS_DIR=${reports_dir@Q}

NEW_STATE_PACKAGES_LIST="\${NEW_STATE}/.github/workflows/portage-stable-packages-list"

AUX_DIR=${aux_dir@Q}

EOF

    # shellcheck disable=SC1090 # generated file
    source "${globals_file}"

    local last_nightly_version_id last_nightly_build_id
    # shellcheck disable=SC1091,SC2153 # sourcing generated file, NEW_STATE is not misspelled
    last_nightly_version_id=$(source "${NEW_STATE}/sdk_container/.repo/manifests/version.txt"; printf '%s' "${FLATCAR_VERSION_ID}")
    # shellcheck disable=SC1091 # sourcing generated file
    last_nightly_build_id=$(source "${NEW_STATE}/sdk_container/.repo/manifests/version.txt"; printf '%s' "${FLATCAR_BUILD_ID}")

    local -a locals definitions
    locals=()
    definitions=()
    local packages_image_var_name packages_image_name
    for arch in "${ARCHES[@]}"; do
        packages_image_var_name="${arch^^}_PACKAGES_IMAGE"
        packages_image_name="flatcar-packages-${arch}:${last_nightly_version_id}-${last_nightly_build_id}"
        locals+=( "${packages_image_var_name@Q}" )
        definitions+=( "${packages_image_var_name}=${packages_image_name@Q}" )
    done

    printf '%s\n' '' "local ${locals[*]}" '' "${definitions[@]}" >>"${globals_file}"
}

# make sure to call the following beforehand:
#
# local -x "${GIT_ENV_VARS[@]}"
function setup_git_env() {
    local bot_name bot_email role what

    # shellcheck disable=SC2034 # used indirectly
    bot_name='Flatcar Buildbot'
    # shellcheck disable=SC2034 # used indirectly
    bot_email='buildbot@flatcar-linux.org'
    for role in AUTHOR COMMITTER; do
        for what in name email; do
            local -n var="GIT_${role}_${what^^}"
            local -n value="bot_${what}"
            # shellcheck disable=SC2034 # it's a reference to external variable
            var=${value}
            unset -n value
            unset -n var
        done
    done
}

function run_sync() {
    local gentoo
    gentoo=${1}; shift

    local -a missing_in_scripts missing_in_gentoo
    missing_in_scripts=()
    missing_in_gentoo=()

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -x "${GIT_ENV_VARS[@]}"
    setup_git_env

    local -a packages_to_update
    packages_to_update=()

    local package
    while read -r package; do
        # shellcheck disable=SC2153 # NEW_PORTAGE_STABLE is not a misspelling, it comes from globals file
        if [[ ! -e "${NEW_PORTAGE_STABLE}/${package}" ]]; then
            # If this happens, it means that the package was moved to overlay
            # or dropped, the list ought to be updated.
            missing_in_scripts+=("${package}")
            continue
        fi
        if [[ ! -e "${gentoo}/${package}" ]]; then
            # If this happens, it means that the package was obsoleted or moved
            # in Gentoo. The obsoletion needs to be handled in the case-by-case
            # manner, while move should be handled by doing the same move
            # in portage-stable. The build should not break because of the move,
            # because most likely it's already reflected in the profiles/updates
            # directory.
            missing_in_gentoo+=("${package}")
            continue
        fi
        packages_to_update+=( "${package}" )
    done < <(cat_meaningful "${NEW_STATE_PACKAGES_LIST}")
    # shellcheck disable=SC2153 # SYNC_SCRIPT is not a misspelling
    env --chdir="${NEW_PORTAGE_STABLE}" "${SYNC_SCRIPT}" -b -- "${gentoo}" "${packages_to_update[@]}"

    save_missing_in_scripts "${missing_in_scripts[@]}"
    save_missing_in_gentoo "${missing_in_gentoo[@]}"
}

function cat_meaningful() {
    local file
    file=${1}; shift

    xgrep '^[^#]' "${file}"
}

function save_simple_package_list() {
    local file
    file=${1}; shift
    # rest are packages

    add_cleanup "rm -f ${file@Q}"
    if [[ ${#} -eq 0 ]]; then
        truncate --size=0 "${file}"
    else
        printf '%s\n' "${@}" >"${file}"
    fi
}

function load_simple_package_list() {
    local file packages_var_name
    file=${1}; shift
    packages_var_name=${1}; shift

    mapfile -t "${packages_var_name}" <"${file}"
}

function save_missing_packages() {
    local dir file
    dir=${1}; shift
    file=${1}; shift

    create_cleanup_dir "${dir}"
    save_simple_package_list "${dir}/${file}" "${@}"
}

function create_cleanup_dir() {
    local dir
    dir=${1}; shift
    if [[ ! -d "${dir}" ]]; then
        add_cleanup "rmdir ${dir@Q}"
        mkdir "${dir}"
    fi
}

function save_missing_in_scripts() {
    save_missing_packages "${WORKDIR}/missing_in_scripts" "saved_list" "${@}"
}

function save_missing_in_gentoo() {
    save_missing_packages "${WORKDIR}/missing_in_gentoo" "saved_list" "${@}"
}

function load_missing_in_scripts() {
    local packages_var_name
    packages_var_name=${1}; shift

    load_simple_package_list "${WORKDIR}/missing_in_scripts/saved_list" "${packages_var_name}"
}

function load_missing_in_gentoo() {
    local packages_var_name
    packages_var_name=${1}; shift

    load_simple_package_list "${WORKDIR}/missing_in_gentoo/saved_list" "${packages_var_name}"
}

function handle_missing_in_scripts() {
    local -a hmis_missing_in_scripts
    hmis_missing_in_scripts=()
    load_missing_in_scripts hmis_missing_in_scripts

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    if [[ ${#hmis_missing_in_scripts[@]} -eq 0 ]]; then
        return 0;
    fi

    # Remove missing in scripts entries from package automation
    local dir
    dir="${WORKDIR}/missing_in_scripts"
    create_cleanup_dir "${dir}"
    local missing_re
    join_by missing_re '\|' "${missing_in_scripts[@]}"
    add_cleanup "rm -f ${dir@Q}/pkg_list"
    xgrep --invert-match --line-regexp --regexp="${missing_re}" "${NEW_STATE_PACKAGES_LIST}" >"${dir}/pkg_list"
    # shellcheck disable=SC2153 # PKG_LIST_SORT_SCRIPT is not a misspelling
    "${PKG_LIST_SORT_SCRIPT}" "${dir}/pkg_list" >"${NEW_STATE_PACKAGES_LIST}"

    local -x "${GIT_ENV_VARS[@]}"
    setup_git_env

    git -C "${NEW_STATE}" add "${NEW_STATE_PACKAGES_LIST}"
    git -C "${NEW_STATE}" commit -m '.github: Drop missing packages from automation'
}

function lines_to_file_truncate() {
    printf '%s\n' "${@:2}" >"${1}"
}

function lines_to_file() {
    printf '%s\n' "${@:2}" >>"${1}"
}

function manual() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    # shellcheck disable=SC2153 # REPORTS_DIR is not a misspelling, it comes from globals file
    lines_to_file "${REPORTS_DIR}/manual-work-needed" "${@}"
}

function pkg_warn() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    lines_to_file "${REPORTS_DIR}/warnings" "${@}"
}

function devel_warn() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    lines_to_file "${REPORTS_DIR}/developer-warnings" "${@}"
}

function handle_missing_in_gentoo() {
    local gentoo
    gentoo=${1}; shift

    local -A hmig_renamed_old_to_new_map hmig_renamed_new_to_old_map
    hmig_renamed_old_to_new_map=()
    hmig_renamed_new_to_old_map=()

    local -a hmig_missing_in_gentoo
    hmig_missing_in_gentoo=()
    load_missing_in_gentoo hmig_missing_in_gentoo

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    if [[ ${#hmig_missing_in_gentoo[@]} -gt 0 ]]; then
        local -a renamed_from renamed_to
        renamed_from=()
        renamed_to=()

        local -x "${GIT_ENV_VARS[@]}"
        setup_git_env

        local missing new_name old_basename new_basename ebuild ebuild_version_ext new_ebuild_filename
        for missing in "${hmig_missing_in_gentoo[@]}"; do
            new_name=$(xgrep --recursive --regexp="^move ${missing} " "${NEW_PORTAGE_STABLE}/profiles/updates/" | cut -d' ' -f3)
            if [[ -z "${new_name}" ]]; then
                manual "- package ${missing} is gone from Gentoo and no rename found"
                continue
            fi
            mkdir -p "${NEW_PORTAGE_STABLE}/${new_name%/*}"
            git -C "${NEW_STATE}" mv "${NEW_PORTAGE_STABLE}/${missing}" "${NEW_PORTAGE_STABLE}/${new_name}"
            basename_out "${missing}" old_basename
            basename_out "${new_name}" new_basename
            if [[ "${old_basename}" != "${new_basename}" ]]; then
                for ebuild in "${NEW_PORTAGE_STABLE}/${new_name}/${old_basename}-"*'.ebuild'; do
                    # 1.2.3-r4.ebuild
                    ebuild_version_ext=${ebuild##*/"${old_basename}-"}
                    new_ebuild_filename="${new_basename}-${ebuild_version_ext}"
                    git -C "${NEW_STATE}" mv "${ebuild}" "${NEW_PORTAGE_STABLE}/${new_name}/${new_ebuild_filename}"
                done
            fi
            git -C "${NEW_STATE}" commit "${new_name}: Renamed from ${missing}"
            env --chdir="${NEW_PORTAGE_STABLE}" "${SYNC_SCRIPT}" -b -- "${gentoo}" "${new_name}"
            renamed_from+=("${missing}")
            renamed_to+=("${new_name}")
            # shellcheck disable=SC2034 # used by name at the bottom of the function
            hmig_renamed_new_to_old_map["${new_name}"]="${missing}"
            # shellcheck disable=SC2034 # used by name at the bottom of the function
            hmig_renamed_old_to_new_map["${missing}"]="${new_name}"
        done

        local dir renamed_re
        if [[ ${#renamed_from[@]} -gt 0 ]]; then
            dir="${WORKDIR}/missing_in_gentoo"
            add_cleanup "rmdir ${dir@Q}"
            mkdir "${dir}"
            join_by renamed_re '\|' "${renamed_from[@]}"
            add_cleanup "rm -f ${dir@Q}/pkg_list"
            {
                xgrep --invert-match --line-regexp --regexp="${renamed_re}" "${NEW_STATE_PACKAGES_LIST}"
                printf '%s\n' "${renamed_to[@]}"
            } >"${dir}/pkg_list"
            "${PKG_LIST_SORT_SCRIPT}" "${dir}/pkg_list" >"${NEW_STATE_PACKAGES_LIST}"
            git -C "${NEW_STATE}" add "${NEW_STATE_PACKAGES_LIST}"
            git -C "${NEW_STATE}" commit -m '.github: Update package names in automation'
        fi
    fi

    save_rename_maps hmig_renamed_old_to_new_map hmig_renamed_new_to_old_map
}

function process_listings() {
    local pkg_to_tags_mvm_var_name
    pkg_to_tags_mvm_var_name=${1}

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local eclass ver_ere pkg_ere
    # shellcheck disable=SC2153 # PORTAGE_STABLE_SUFFIX is not a misspelling
    eclass="${PKG_AUTO_DIR}/../${PORTAGE_STABLE_SUFFIX}/eclass/eapi7-ver.eclass"
    # line is like '   re="<regexp>"'
    ver_ere=$(grep -e 're=' "${eclass}" || fail "no 're=' line found in eapi7-ver.eclass")
    if [[ -z ${ver_ere} ]]; then
        fail 'empty version regex from eapi7-ver.eclass'
    fi
    # strip everything until first quotes
    ver_ere=${ver_ere#*'"'}
    # strip last quote
    ver_ere=${ver_ere%'"'*}
    # regexp begins with ^ and ends with $, so strip them too
    ver_ere=${ver_ere#'^'}
    ver_ere=${ver_ere#'$'}
    pkg_ere='[a-z0-9]*-\?[a-z0-9]*/[a-z0-9A-Z_+-]*'

    mvm_declare pl_pkg_to_tags_set_mvm mvm_mvc_set

    local arch kind file listing pkg
    for arch in "${ARCHES[@]}"; do
        for kind in "${!LISTING_KINDS[@]}"; do
            file=${LISTING_KINDS["${kind}"]}
            listing="${AUX_DIR}/${arch}/${file}"
            # lines are like as follows:
            #
            # acct-group/adm-0-r2::portage-stable
            while read -r pkg; do
                mvm_add pl_pkg_to_tags_set_mvm "${pkg}" "${kind^^}"
            done < <(sed -E -e 's#^('"${pkg_ere}"')-'"${ver_ere}"'::.*#\1#' "${listing}")
        done
    done

    mvm_iterate pl_pkg_to_tags_set_mvm set_mvm_to_array_mvm_cb "${pkg_to_tags_mvm_var_name}"
    mvm_unset pl_pkg_to_tags_set_mvm
}

function set_mvm_to_array_mvm_cb() {
    local pkg_to_tags_mvm_var_name pkg set_var_name
    pkg_to_tags_mvm_var_name=${1}; shift
    pkg=${1}; shift
    set_var_name=${1}; shift
    local -n set_ref="${set_var_name}"
    # rest are set items

    local removed
    removed=''
    local -a prod_item
    prod_item=()
    if [[ -n ${set_ref['prod']:-} ]]; then
        prod_item+=('prod')
        unset "set_ref['prod']"
        removed=x
    fi
    local -a sorted_items
    mapfile -t sorted_items < <(printf '%s\n' "${!set_ref[@]}" | sort)
    if [[ -n ${removed} ]]; then
        set_ref['prod']=x
    fi

    mvm_add "${pkg_to_tags_mvm_var_name}" "${pkg}" "${prod_item[@]}" "${sorted_items[@]}"
}

function dup_add_cleanup() {
    local dup_cleanups_var_name
    dup_cleanups_var_name=${1}; shift
    local -n dup_cleanups_ref="${dup_cleanups_var_name}"

    add_cleanup "${@}"
    dup_cleanups_ref=( "${@}" "${dup_cleanups_ref[@]}" )
}

function execute_lines() {
    local commands_file
    commands_file=$(mktemp)
    printf '%s\n' "${@}" "rm -f ${commands_file@Q}" >"${commands_file}"
    # shellcheck disable=SC1090 # sourcing generated file
    source "${commands_file}"
}

function generate_sdk_reports() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    add_cleanup "rmdir ${WORKDIR@Q}/pkg-reports"
    mkdir "${WORKDIR}/pkg-reports"

    local arch packages_image_var_name packages_image_name
    local sdk_run_kind state_var_name sdk_run_state state_branch_var_name sdk_run_state_branch
    local file full_file
    local rv
    local sdk_reports_dir salvaged_dir
    local -a report_files
    for arch in "${ARCHES[@]}"; do
        packages_image_var_name="${arch^^}_PACKAGES_IMAGE"
        packages_image_name=${!packages_image_var_name}
        if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep --quiet --line-regexp --fixed-strings "${packages_image_name}"; then
            fail "No SDK image named '${packages_image_name}' available locally, pull it before running this script"
        fi

        # shellcheck disable=SC2153 # WHICH is not a misspelling, it comes from globals file
        for sdk_run_kind in "${WHICH[@]}"; do
            state_var_name="${sdk_run_kind^^}_STATE"
            sdk_run_state="${!state_var_name}_sdk_run_${arch}"
            state_branch_var_name="${sdk_run_kind^^}_STATE_BRANCH"
            sdk_run_state_branch="${!state_branch_var_name}-sdk-run-${arch}"

            add_cleanup \
                "git -C ${sdk_run_state@Q} reset --hard HEAD" \
                "git -C ${sdk_run_state@Q} clean -ffdx" \
                "git -C ${SCRIPTS@Q} worktree remove ${sdk_run_state@Q}" \
                "git -C ${SCRIPTS@Q} branch -D ${sdk_run_state_branch@Q}"
            git -C "${SCRIPTS}" \
                worktree add -b "${sdk_run_state_branch}" "${sdk_run_state}" "${!state_branch_var_name}"
            for file in inside_sdk_container.sh stuff.sh print_profile_tree.sh; do
                full_file="${sdk_run_state}/${file}"
                add_cleanup "rm -f ${full_file@Q}"
                cp -a "${PKG_AUTO_DIR}/${file}" "${sdk_run_state}"
            done
            rv=0
            env --chdir "${sdk_run_state}" \
                ./run_sdk_container \
                -C "${packages_image_name}" \
                -n "pkg-${sdk_run_kind}-${arch}" \
                -a "${arch}" \
                --rm \
                ./inside_sdk_container.sh "${arch}" pkg-reports || rv=${?}
            if [[ ${rv} -ne 0 ]]; then
                {
                    salvaged_dir="${REPORTS_DIR}/salvaged-reports"
                    info "run_sdk_container finished with exit status ${rv}, printing the warnings below for a clue"
                    info
                    for file in "${sdk_run_state}/pkg-reports/"*'-warnings'; do
                        info "from ${file}:"
                        echo
                        cat "${file}"
                        echo
                    done
                    info
                    info 'the following steps will work if you configured this run to use cleanups'
                    info 'other than the "trap" kind'
                    info
                    info 'entering the SDK to investigate issues can be done as follows:'
                    info
                    info "${PKG_AUTO_DIR@Q}/debug_new_state.sh ${WORKDIR@Q} ${arch@Q} fixed-stuff"
                    info
                    info 'this will save your git changes to the fixed-stuff branch,'
                    info 'so after figuring out a fix and committing it, do the following:'
                    info
                    info "${PKG_AUTO_DIR@Q}/generate_config.sh -b ${WORKDIR@Q} -x \"\${YOUR_CLEANUP}\" -n fixed-stuff fixed-config"
                    info "${PKG_AUTO_DIR@Q}/generate_reports.sh -w new-workdir fixed-config"
                    info
                    info 'whatever reports generated by the failed run are saved in'
                    info "${salvaged_dir@Q} directory"
                    info
                    info 'storing salvaged reports'
                    info
                } >&2
                rm -rf "${salvaged_dir}"
                cp -a "${sdk_run_state}/pkg-reports" "${salvaged_dir}"
                fail "copying done, stopping now"
            fi
            sdk_reports_dir="${WORKDIR}/pkg-reports/${sdk_run_kind}-${arch}"
            report_files=()
            for full_file in "${sdk_run_state}/pkg-reports/"*; do
                file=${full_file##"${sdk_run_state}/pkg-reports/"}
                report_files+=( "${sdk_reports_dir}/${file}" )
            done
            add_cleanup \
                "rm -f ${report_files[*]@Q}" \
                "rmdir ${sdk_reports_dir@Q}"
            mv "${sdk_run_state}/pkg-reports" "${sdk_reports_dir}"
        done
    done
    cp -a "${WORKDIR}/pkg-reports" "${REPORTS_DIR}/reports-from-sdk"
}

source "${PKG_AUTO_DIR}/mvm.sh"

# pkginfo: map[pkg]map[slot]version
function pkginfo_name() {
    local which arch report pi_name_var_name

    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift
    pi_name_var_name=${1}; shift
    local -n pi_name_ref="${pi_name_var_name}"

    # shellcheck disable=SC2034 # it's a reference to external variable
    pi_name_ref="pkginfo_${which}_${arch}_${report//-/_}_pimap_mvm"
}

function pkginfo_constructor() {
    mvm_mvc_map_constructor "${@}"
}

function pkginfo_destructor() {
    mvm_mvc_map_destructor "${@}"
}

function pkginfo_adder() {
    local map_var_name
    map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n map_ref="${map_var_name}"

    local mark
    while [[ ${#} -gt 1 ]]; do
        mark=${map_ref["${1}"]:-}
        if [[ -n "${mark}" ]]; then
            fail "multiple versions for a single slot for a package in a single report"
        fi
        map_ref["${1}"]=${2}
        shift 2
    done
}

function pkginfo_declare() {
    local which arch report pi_name_var_name
    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift
    pi_name_var_name=${1}; shift

    pkginfo_name "${which}" "${arch}" "${report}" "${pi_name_var_name}"

    local -a extras
    extras=(
        'which' "${which}"
        'arch' "${arch}"
        'report' "${report}"
    )

    mvm_declare "${!pi_name_var_name}" pkginfo -- "${extras[@]}"
}

function pkginfo_unset() {
    local which arch report
    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift

    local piu_pi_name
    pkginfo_name "${which}" "${arch}" "${report}" piu_pi_name

    mvm_unset "${piu_pi_name}"
}

function pkginfo_process_file() {
    mvm_call "${1}" pkginfo_c_process_file "${@:2}"
}

function pkginfo_c_process_file() {
    local pkg_set_var_name pkg_slots_set_mvm_var_name
    pkg_set_var_name=${1}; shift
    local -n pkg_set_ref="${pkg_set_var_name}"
    pkg_slots_set_mvm_var_name=${1}; shift

    local which arch report
    mvm_c_get_extra 'which' which
    mvm_c_get_extra 'arch' arch
    mvm_c_get_extra 'report' report

    local pkg version_slot throw_away v s
    # shellcheck disable=SC2034 # throw_away is unused, it's here for read to store the rest of the line if there is something else
    while read -r pkg version_slot throw_away; do
        v=${version_slot%%:*}
        s=${version_slot##*:}
        mvm_c_add "${pkg}" "${s}" "${v}"
        # shellcheck disable=SC2034 # it's a reference to external variable
        pkg_set_ref["${pkg}"]='x'
        mvm_add "${pkg_slots_set_mvm_var_name}" "${pkg}" "${s}"
    done <"${WORKDIR}/pkg-reports/${which}-${arch}/${report}"
}

function pkginfo_profile() {
    mvm_call "${1}" pkginfo_c_profile "${@:2}"
}

function pkginfo_c_profile() {
    local profile_var_name
    profile_var_name=${1}; shift

    local which arch report
    mvm_c_get_extra 'which' which
    mvm_c_get_extra 'arch' arch
    mvm_c_get_extra 'report' report

    printf -v "${profile_var_name}" '%s-%s-%s' "${which}" "${arch}" "${report}"
}

function read_reports() {
    local all_pkgs_var_name pkg_slots_set_mvm_var_name
    all_pkgs_var_name=${1}; shift
    pkg_slots_set_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -A all_packages_set
    all_packages_set=()

    local arch which report rr_pimap_mvm_var_name
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in "${REPORTS[@]}"; do
                pkginfo_declare "${which}" "${arch}" "${report}" rr_pimap_mvm_var_name
                pkginfo_process_file "${rr_pimap_mvm_var_name}" all_packages_set "${pkg_slots_set_mvm_var_name}"
            done
        done
    done
    local -n all_pkgs_ref="${all_pkgs_var_name}"
    all_pkgs_ref=( "${!all_packages_set[@]}" )
}

function unset_report_mvms() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local arch which report
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in "${REPORTS[@]}"; do
                pkginfo_unset "${which}" "${arch}" "${report}"
            done
        done
    done
}

###
### BEGIN GENTOO VER COMP HACKS
###

# shellcheck disable=SC2034 # it's here only for the eapi7-ver.eclass
EAPI=6
function die() {
    fail "$*"
}

# shellcheck disable=SC1091 # sourcing external file
source "${PKG_AUTO_DIR}/../sdk_container/src/third_party/portage-stable/eclass/eapi7-ver.eclass"

unset EAPI

function gentoo_ver_test_out() {
    local v1 op v2 out_var_name
    v1=${1}; shift
    op=${1}; shift
    v2=${1}; shift
    out_var_name=${1}; shift
    local -n out_ref="${out_var_name}"

    out_ref=0
    ver_test "${v1}" "${op}" "${v2}" || out_ref=${?}
    return 0
}

function gentoo_ver_test() {
    local v1 op v2
    v1=${1}; shift
    op=${1}; shift
    v2=${1}; shift

    local gvt_retval
    gentoo_ver_test_out "${v1}" "${op}" "${v2}" gvt_retval
    return "${gvt_retval}"
}

# symbolic names for use with gentoo_ver_cmp
GV_LT=1
GV_EQ=2
GV_GT=3

# 1 - version 1
# 2 - version 2
# 3 - name of variable to store the result in (1 when v1 < v2, 2 when v1 == v2, 3 when v1 > v2)
function gentoo_ver_cmp_out() {
    local v1 v2 out_var_name
    v1=${1}; shift
    v2=${1}; shift
    out_var_name=${1}; shift
    local -n out_ref="${out_var_name}"

    out_ref=0
    _ver_compare "${v1}" "${v2}" || out_ref=${?}
    case ${out_ref} in
        1|2|3)
            return 0
            ;;
        *)
            fail "unexpected return value ${out_ref} from _ver_compare for ${v1} and ${v2}"
            ;;
    esac
}

# 1 - version 1
# 2 - version 2
function gentoo_ver_cmp() {
    local v1 v2 out_var_name
    v1=${1}; shift
    v2=${1}; shift

    local gvc_retval
    gentoo_ver_cmp_out "${v1}" "${v2}" gvc_retval
    return "${gvc_retval}"
}

###
### END GENTOO VER COMP HACKS
###

function ver_min_max() {
    local min_var_name max_var_name
    min_var_name=${1}; shift
    local -n min_ref="${min_var_name}"
    max_var_name=${1}; shift
    local -n max_ref="${max_var_name}"

    local min max v
    min=''
    max=''
    for v; do
        if [[ -z ${min} ]] || gentoo_ver_test "${v}" -lt "${min}"; then
            min=${v}
        fi
        if [[ -z ${max} ]] || gentoo_ver_test "${v}" -gt "${max}"; then
            max=${v}
        fi
    done
    # shellcheck disable=SC2034 # it's a reference to external variable
    min_ref="${min}"
    # shellcheck disable=SC2034 # it's a reference to external variable
    max_ref="${max}"
}

# 1 - package
# 2 - name of the package info mvm for profile 1
# 3 - name of the package info mvm for profile 2
# 4 - name of the pkg to slots to version mvm
# 5 - name of the pkg to all slots mvm
function consistency_check_for_package() {
    local pkg pi1_pimap_mvm_var_name pi2_pimap_mvm_var_name pkg_slot_verminmax_map_mvm_var_name pkg_slots_set_mvm_var_name
    pkg=${1}; shift
    pi1_pimap_mvm_var_name=${1}; shift
    pi2_pimap_mvm_var_name=${1}; shift
    pkg_slot_verminmax_map_mvm_var_name=${1}; shift
    pkg_slots_set_mvm_var_name=${1}; shift

    local ccfp_slot_version1_map_var_name ccfp_slot_version2_map_var_name
    mvm_get "${pi1_pimap_mvm_var_name}" "${pkg}" ccfp_slot_version1_map_var_name
    mvm_get "${pi2_pimap_mvm_var_name}" "${pkg}" ccfp_slot_version2_map_var_name

    local -A empty_map
    empty_map=()

    local -n slot_version1_map="${ccfp_slot_version1_map_var_name:-empty_map}"
    local -n slot_version2_map="${ccfp_slot_version2_map_var_name:-empty_map}"

    local ccfp_slots_set_var_name
    mvm_get "${pkg_slots_set_mvm_var_name}" "${pkg}" ccfp_slots_set_var_name
    local -n slots_set_ref="${ccfp_slots_set_var_name}"

    local -a profile_1_slots profile_2_slots common_slots
    profile_1_slots=()
    profile_2_slots=()
    common_slots=()

    local ccfp_profile_1 ccfp_profile_2
    pkginfo_profile "${pi1_pimap_mvm_var_name}" ccfp_profile_1
    pkginfo_profile "${pi2_pimap_mvm_var_name}" ccfp_profile_2

    local s v1 v2 ccfp_min ccfp_max mm
    for s in "${!slots_set_ref[@]}"; do
        v1=${slot_version1_map["${s}"]:-}
        v2=${slot_version2_map["${s}"]:-}

        if [[ -n ${v1} ]] && [[ -n ${v2} ]]; then
            common_slots+=( "${s}" )
            if [[ ${v1} != "${v2}" ]]; then
                pkg_warn \
                    "- version mismatch:" \
                    "  - package ${pkg}" \
                    "  - slot ${s}" \
                    "  - profile 1: ${ccfp_profile_1}" \
                    "    - version: ${v1}" \
                    "  - profile 1: ${ccfp_profile_2}" \
                    "    - version: ${v2}"
            fi
            ver_min_max ccfp_min ccfp_max "${v1}" "${v2}"
            mm="${ccfp_min}:${ccfp_max}"
        elif [[ -n ${v1} ]]; then
            # only side1 has the slot
            profile_1_slots+=( "${s}" )
            mm="${v1}:${v1}"
        elif [[ -n ${v2} ]]; then
            # only side 2 has the slot
            profile_2_slots+=( "${s}" )
            mm="${v2}:${v2}"
        else
            continue
        fi

        mvm_add "${pkg_slot_verminmax_map_mvm_var_name}" "${pkg}" "${s}" "${mm}"
    done
    if [[ ${#common_slots[@]} -gt 0 ]]; then
        if [[ ${#profile_1_slots[@]} -gt 0 ]] || [[ ${#profile_2_slots[@]} -gt 0 ]]; then
            pkg_warn \
                "- suspicious:" \
                "  - package ${pkg}" \
                "  - profile 1: ${ccfp_profile_1}" \
                "  - profile 2: ${ccfp_profile_2}" \
                "  - common slots: ${common_slots[*]}" \
                "  - slots only in profile 1: ${profile_1_slots[*]}" \
                "  - slots only in profile 2: ${profile_2_slots[*]}" \
                "  - what: there are slots that exist only on one profile while both profiles also have some common slots"
        fi
    fi
}

# consistency checks between:
# not yet: amd64 sdk <-> arm64 sdk
# amd64 sdk <-> amd64 board
# not yet: arm64 sdk <-> arm64 board
# amd64 board <-> arm64 board
function consistency_checks() {
    local which all_pkgs_var_name pkg_slots_set_mvm_var_name pkg_slot_verminmax_mvm_var_name
    which=${1}; shift
    all_pkgs_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n all_pkgs_ref="${all_pkgs_var_name}"
    pkg_slots_set_mvm_var_name=${1}; shift
    pkg_slot_verminmax_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local cc_pimap_mvm_1_var_name cc_pimap_mvm_2_var_name pkg

    # amd64 sdk <-> amd64 board
    pkginfo_name "${which}" amd64 "${SDK_PKGS}" cc_pimap_mvm_1_var_name
    pkginfo_name "${which}" amd64 "${BOARD_PKGS}" cc_pimap_mvm_2_var_name
    mvm_declare cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm mvm_mvc_map
    for pkg in "${all_pkgs_ref[@]}"; do
        consistency_check_for_package "${pkg}" "${cc_pimap_mvm_1_var_name}" "${cc_pimap_mvm_2_var_name}" cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm "${pkg_slots_set_mvm_var_name}"
    done

    # amd64 board <-> arm64 board
    pkginfo_name "${which}" amd64 "${BOARD_PKGS}" cc_pimap_mvm_1_var_name
    pkginfo_name "${which}" arm64 "${BOARD_PKGS}" cc_pimap_mvm_2_var_name
    mvm_declare cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm mvm_mvc_map
    for pkg in "${all_pkgs_ref[@]}"; do
        consistency_check_for_package "${pkg}" "${cc_pimap_mvm_1_var_name}" "${cc_pimap_mvm_2_var_name}" cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm "${pkg_slots_set_mvm_var_name}"
    done

    local cc_slot_verminmax1_map_var_name cc_slot_verminmax2_map_var_name
    local cc_slots_set_var_name s verminmax1 verminmax2 cc_min cc_max verminmax
    local -A empty_map
    # shellcheck disable=SC2034 # used indirectly below
    empty_map=()
    for pkg in "${all_pkgs_ref[@]}"; do
        mvm_get cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm "${pkg}" cc_slot_verminmax1_map_var_name
        mvm_get cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm "${pkg}" cc_slot_verminmax2_map_var_name
        mvm_get "${pkg_slots_set_mvm_var_name}" "${pkg}" cc_slots_set_var_name
        local -n slot_verminmax1_map_ref="${cc_slot_verminmax1_map_var_name:-empty_map}"
        local -n slot_verminmax2_map_ref="${cc_slot_verminmax2_map_var_name:-empty_map}"
        local -n slots_set_ref="${cc_slots_set_var_name}"
        for s in "${!slots_set_ref[@]}"; do
            verminmax1=${slot_verminmax1_map_ref["${s}"]:-}
            verminmax2=${slot_verminmax2_map_ref["${s}"]:-}
            if [[ -n "${verminmax1}" ]] && [[ -n "${verminmax2}" ]]; then
                ver_min_max \
                    cc_min cc_max \
                    "${verminmax1%%:*}" "${verminmax1##*:}" "${verminmax2%%:*}" "${verminmax2##*:}"
                verminmax="${cc_min}:${cc_max}"
            elif [[ -n "${verminmax1}" ]]; then
                verminmax="${verminmax1}"
            elif [[ -n "${verminmax2}" ]]; then
                verminmax="${verminmax2}"
            else
                continue
            fi
            mvm_add "${pkg_slot_verminmax_mvm_var_name}" "${pkg}" "${s}" "${verminmax}"
        done
        unset -n slots_set_ref slot_verminmax2_map_ref slot_verminmax1_map_ref
    done
    mvm_unset cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm
    mvm_unset cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm
}

function read_package_sources() {
    local package_sources_map_var_name
    package_sources_map_var_name=${1}; shift
    local -n package_sources_map_ref="${package_sources_map_var_name}"

    local arch which report pkg repo saved_repo
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in sdk-package-repos board-package-repos; do
                while read -r pkg repo; do
                    saved_repo=${package_sources_map_ref["${pkg}"]:-}
                    if [[ -n ${saved_repo} ]]; then
                        if [[ ${saved_repo} != "${repo}" ]]; then
                            pkg_warn \
                                '- different repos used for the package:' \
                                "  - package: ${pkg}" \
                                '  - repos:' \
                                "    - ${saved_repo}" \
                                "    - ${repo}"
                        fi
                    else
                        package_sources_map_ref["${pkg}"]=${repo}
                    fi
                done <"${WORKDIR}/pkg-reports/${which}-${arch}/${report}"
            done
        done
    done
}

function handle_package_changes() {
    local renamed_old_to_new_map_var_name renamed_new_to_old_map_var_name pkg_to_tags_mvm_var_name
    renamed_old_to_new_map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n renamed_old_to_new_map_ref="${renamed_old_to_new_map_var_name}"
    renamed_new_to_old_map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n renamed_new_to_old_map_ref="${renamed_new_to_old_map_var_name}"
    pkg_to_tags_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a hpc_all_pkgs
    hpc_all_pkgs=()

    mvm_declare hpc_pkg_slots_set_mvm mvm_mvc_set
    read_reports hpc_all_pkgs hpc_pkg_slots_set_mvm

    mvm_declare hpc_old_pkg_slot_verminmax_map_mvm mvm_mvc_map
    mvm_declare hpc_new_pkg_slot_verminmax_map_mvm mvm_mvc_map
    consistency_checks old hpc_all_pkgs hpc_pkg_slots_set_mvm hpc_old_pkg_slot_verminmax_map_mvm
    consistency_checks new hpc_all_pkgs hpc_pkg_slots_set_mvm hpc_new_pkg_slot_verminmax_map_mvm

    unset_report_mvms

    # TODO: when we handle moving packages between repos, then there
    # should be two maps, for old and new state
    local -A hpc_package_sources_map
    hpc_package_sources_map=()
    read_package_sources hpc_package_sources_map

    mkdir -p "${REPORTS_DIR}/updates"

    local -a old_pkgs new_pkgs
    old_pkgs=()
    new_pkgs=()

    local pkg other
    for pkg in "${hpc_all_pkgs[@]}"; do
        other=${renamed_old_to_new_map_ref["${pkg}"]:-}
        if [[ -n "${other}" ]]; then
            old_pkgs+=("${pkg}")
            new_pkgs+=("${other}")
            continue
        fi
        other=${renamed_new_to_old_map_ref["${pkg}"]:-}
        if [[ -n "${other}" ]]; then
            continue
        fi
        old_pkgs+=("${pkg}")
        new_pkgs+=("${pkg}")
    done

    local pkg_idx
    pkg_idx=0

    local old_name new_name old_repo new_repo
    local hpc_old_slots_set_var_name hpc_new_slots_set_var_name
    local hpc_old_slot_verminmax_map_var_name hpc_new_slot_verminmax_map_var_name
    local s hpc_old_s hpc_new_s
    local old_verminmax new_verminmax
    local old_version new_version
    local hpc_cmp_result
    local -A hpc_only_old_slots_set hpc_only_new_slots_set hpc_common_slots_set
    local -a lines
    local hpc_update_dir
    local -A empty_map_or_set
    # shellcheck disable=SC2034 # used by name below, in a special case
    empty_map_or_set=()
    while [[ ${pkg_idx} -lt ${#old_pkgs[@]} ]]; do
        old_name=${old_pkgs["${pkg_idx}"]}
        new_name=${new_pkgs["${pkg_idx}"]}
        pkg_idx=$((pkg_idx + 1))
        old_repo=${hpc_package_sources_map["${old_name}"]}
        new_repo=${hpc_package_sources_map["${new_name}"]}
        if [[ ${old_repo} != "${new_repo}" ]]; then
            pkg_warn \
                '- package has moved between repos? unsupported for now' \
                "  - old package and repo: ${old_name} ${old_repo}" \
                "  - new package and repo: ${new_name} ${new_repo}"
            continue
        fi
        if [[ ${new_repo} != 'portage-stable' ]]; then
            # coreos-overlay packages will need a separate handling
            continue
        fi

        mvm_get hpc_pkg_slots_set_mvm "${old_name}" hpc_old_slots_set_var_name
        mvm_get hpc_pkg_slots_set_mvm "${new_name}" hpc_new_slots_set_var_name
        local -n hpc_old_slots_set_ref="${hpc_old_slots_set_var_name:-empty_map_or_set}"
        local -n hpc_new_slots_set_ref="${hpc_new_slots_set_var_name:-empty_map_or_set}"
        mvm_get hpc_old_pkg_slot_verminmax_map_mvm "${old_name}" hpc_old_slot_verminmax_map_var_name
        mvm_get hpc_new_pkg_slot_verminmax_map_mvm "${new_name}" hpc_new_slot_verminmax_map_var_name
        local -n old_slot_verminmax_map_ref="${hpc_old_slot_verminmax_map_var_name:-empty_map_or_set}"
        local -n new_slot_verminmax_map_ref="${hpc_new_slot_verminmax_map_var_name:-empty_map_or_set}"
        hpc_only_old_slots_set=()
        hpc_only_new_slots_set=()
        hpc_common_slots_set=()
        sets_split \
            hpc_old_slots_set_ref hpc_new_slots_set_ref \
            hpc_only_old_slots_set hpc_only_new_slots_set hpc_common_slots_set
        for s in "${!hpc_common_slots_set[@]}"; do
            old_verminmax=${old_slot_verminmax_map_ref["${s}"]:-}
            new_verminmax=${new_slot_verminmax_map_ref["${s}"]:-}
            if [[ -z "${old_verminmax}" ]] || [[ -z "${new_verminmax}" ]]; then
                devel_warn \
                    "- no minmax info available for old and/or new:" \
                    "  - old package: ${old_name}" \
                    "    - slot: ${s}" \
                    "    - minmax: ${old_verminmax}" \
                    "  - new package: ${new_name}" \
                    "    - slot: ${s}" \
                    "    - minmax: ${new_verminmax}"
                continue
            fi
            update_dir "${new_name}" "${s}" "${s}" hpc_update_dir
            mkdir -p "${hpc_update_dir}"
            old_version=${old_verminmax%%:*}
            new_version=${new_verminmax##*:}
            gentoo_ver_cmp_out "${new_version}" "${old_version}" hpc_cmp_result
            case ${hpc_cmp_result} in
                "${GV_GT}")
                    handle_pkg_update "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}" "${new_version}"
                    ;;
                "${GV_EQ}")
                    handle_pkg_as_is "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}"
                    ;;
                "${GV_LT}")
                    handle_pkg_downgrade "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}" "${new_version}"
                    ;;
            esac
        done
        if [[ ${#hpc_only_old_slots_set[@]} -eq 1 ]] && [[ ${#hpc_only_new_slots_set[@]} -eq 1 ]]; then
            get_nth_from_set 0 hpc_only_old_slots_set hpc_old_s
            old_verminmax=${old_slot_verminmax_map_ref["${hpc_old_s}"]:-}
            get_nth_from_set 0 hpc_only_new_slots_set hpc_new_s
            new_verminmax=${new_slot_verminmax_map_ref["${hpc_new_s}"]:-}
            if [[ -z "${old_verminmax}" ]] || [[ -z "${new_verminmax}" ]]; then
                devel_warn \
                    "- no verminmax info available for old and/or new:" \
                    "  - old package: ${old_name}" \
                    "    - slot: ${hpc_old_s}" \
                    "    - minmax: ${old_verminmax}" \
                    "  - new package: ${new_name}" \
                    "    - slot: ${hpc_new_s}" \
                    "    - minmax: ${new_verminmax}"
                continue
            fi
            update_dir "${new_name}" "${hpc_old_s}" "${hpc_new_s}" hpc_update_dir
            mkdir -p "${hpc_update_dir}"
            old_version=${old_verminmax%%:*}
            new_version=${new_verminmax##*:}
            gentoo_ver_cmp_out "${new_version}" "${old_version}" hpc_cmp_result
            case ${hpc_cmp_result} in
                "${GV_GT}")
                    handle_pkg_update "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}" "${new_version}"
                    ;;
                "${GV_EQ}")
                    handle_pkg_as_is "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}"
                    ;;
                "${GV_LT}")
                    handle_pkg_downgrade "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}" "${new_version}"
                    ;;
            esac
        elif [[ ${#hpc_only_old_slots_set[@]} -gt 0 ]] || [[ ${#hpc_only_new_slots_set[@]} -gt 0 ]]; then
            lines=(
                '- handle package update:'
                '  - old package name:'
                "    - name: ${old_name}"
                '    - slots:'
            )
            for s in "${!hpc_old_slots_set_ref[@]}"; do
                old_verminmax=${old_slot_verminmax_map_ref["${s}"]:-}
                lines+=("      - ${s}, minmax: ${old_verminmax}")
            done
            lines+=(
                '  - new package name:'
                "    - name: ${new_name}"
                '    - slots:'
            )
            for s in "${!hpc_new_slots_set_ref[@]}"; do
                new_verminmax=${new_slot_verminmax_map_ref["${s}"]:-}
                lines+=("      - ${s}, minmax: ${new_verminmax}")
            done
            manual "${lines[@]}"
        fi
        unset -n new_slot_verminmax_map_ref old_slot_verminmax_map_ref hpc_new_slots_set_ref hpc_old_slots_set_ref
    done

    mvm_unset hpc_new_pkg_slot_verminmax_map_mvm
    mvm_unset hpc_old_pkg_slot_verminmax_map_mvm
    mvm_unset hpc_pkg_slots_set_mvm
}

function get_nth_from_set() {
    local idx set_var_name return_var_name
    idx=${1}; shift
    set_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n set_ref="${set_var_name}"
    return_var_name=${1}; shift
    local -n return_ref="${return_var_name}"

    local iter item
    iter=0
    for item in "${!set_ref[@]}"; do
        if [[ ${iter} -eq ${idx} ]]; then
            return_ref=${item}
            return 0
        fi
        iter=$((iter + 1))
    done
    # shellcheck disable=SC2034 # it's a reference to external variable
    return_ref=''
}

function sets_split() {
    local first_set_var_name second_set_var_name only_in_first_set_var_name only_in_second_set_var_name common_set_var_name
    first_set_var_name=${1}; shift
    local -n first_set_ref="${first_set_var_name}"
    second_set_var_name=${1}; shift
    local -n second_set_ref="${second_set_var_name}"
    only_in_first_set_var_name=${1}; shift
    local -n only_in_first_set_ref="${only_in_first_set_var_name}"
    only_in_second_set_var_name=${1}; shift
    local -n only_in_second_set_ref="${only_in_second_set_var_name}"
    common_set_var_name=${1}; shift
    local -n common_set_ref="${common_set_var_name}"

    only_in_first_set_ref=()
    only_in_second_set_ref=()
    common_set_ref=()

    local item mark

    for item in "${!first_set_ref[@]}"; do
        mark=${second_set_ref["${item}"]:-}
        if [[ -z "${mark}" ]]; then
            # shellcheck disable=SC2034 # it's a reference to external variable
            only_in_first_set_ref["${item}"]=x
        else
            # shellcheck disable=SC2034 # it's a reference to external variable
            common_set_ref["${item}"]=x
        fi
    done

    for item in "${!second_set_ref[@]}"; do
        mark=${first_set_ref["${item}"]:-}
        if [[ -z "${mark}" ]]; then
            # shellcheck disable=SC2034 # it's a reference to external variable
            only_in_second_set_ref["${item}"]=x
        fi
    done
}

function handle_pkg_update() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s old new
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local old_no_r new_no_r
    old_no_r=${old%-r+([0-9])}
    new_no_r=${new%-r+([0-9])}

    local pkg_name
    pkg_name=${new_pkg#*/}
    local -a lines
    lines=( "from ${old} to ${new}")
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    fi
    # shellcheck disable=SC2153 # OLD_PORTAGE_STABLE is not a misspelling, it comes from globals file
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${old}" "${new}"
    local hpu_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpu_update_dir
    if [[ ! -s "${hpu_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi
    if gentoo_ver_test "${new_no_r}" -gt "${old_no_r}"; then
        # version bump
        generate_changelog_entry_stub "${pkg_name}" "${new_no_r}"
        lines+=( 'release notes: TODO' )
    fi

    local -a hpu_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${new_pkg}" hpu_tags
    generate_summary_stub "${new_pkg}" "${hpu_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function handle_pkg_as_is() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s v
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    v=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local hpai_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpai_update_dir

    local pkg_name
    pkg_name=${new_pkg#/}
    local -a lines
    lines=( "still at ${v}" )

    local hpai_update_dir_parent hpai_update_dir_parent_2
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    else
        # If absolutely nothing has changed, generate no reports and
        # remove the update directory. There are three levels of
        # directories that may need removing:
        #
        # category/name/slot
        # category/name
        # category
        if diff --recursive "${OLD_PORTAGE_STABLE}/${old_pkg}" "${NEW_PORTAGE_STABLE}/${new_pkg}" >/dev/null 2>/dev/null; then
            rmdir "${hpai_update_dir}"
            dirname_out "${hpai_update_dir}" hpai_update_dir_parent
            if [[ -z $(echo "${hpai_update_dir_parent}"/*) ]]; then
                rmdir "${hpai_update_dir_parent}"
                dirname_out "${hpai_update_dir_parent}" hpai_update_dir_parent_2
                if [[ -z $(echo "${hpai_update_dir_parent_2}"/*) ]]; then
                    rmdir "${hpai_update_dir_parent_2}"
                fi
            fi
            return 0
        fi
    fi
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${v}" "${v}"
    if [[ ! -s "${hpai_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi

    local -a hpai_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${pkg}" hpai_tags
    generate_summary_stub "${new_pkg}" "${hpai_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function handle_pkg_downgrade() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s old new
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local old_no_r new_no_r
    old_no_r=${old%-r+([0-9])}
    new_no_r=${new%-r+([0-9])}

    local pkg_name
    pkg_name=${new_pkg#*/}
    local -a lines
    lines=( "downgraded from ${old} to ${new}" )
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    fi
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${old}" "${new}"
    local hpd_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpd_update_dir
    if [[ ! -s "${hpd_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi
    if gentoo_ver_test "${new_no_r}" -lt "${old_no_r}"; then
        # version bump
        generate_changelog_entry_stub "${pkg_name}" "${new_no_r}"
        lines+=( "release notes: TODO" )
    fi

    local -a hpd_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${new_pkg}" hpd_tags
    generate_summary_stub "${new_pkg}" "${hpd_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function tags_for_pkg() {
    local pkg_to_tags_mvm_var_name pkg tags_var_name
    pkg_to_tags_mvm_var_name=${1}; shift
    pkg=${1}; shift
    tags_var_name=${1}; shift
    local -n tags_ref="${tags_var_name}"

    local tfp_tags_var_name
    mvm_get "${pkg_to_tags_mvm_var_name}" "${pkg}" tfp_tags_var_name

    if [[ -z ${tfp_tags_var_name} ]]; then
        tags_ref=()
    else
        local -n tags_in_mvm="${tfp_tags_var_name}"
        # shellcheck disable=SC2034 # it's a reference to external variable
        tags_ref=( "${tags_in_mvm[@]}" )
    fi
}

function generate_changelog_entry_stub() {
    local pkg_name v
    pkg_name=${1}; shift
    v=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    printf '%s %s ([%s](TODO))\n' '-' "${pkg_name}" "${v}" >>"${REPORTS_DIR}/updates/changelog_stubs"
}

function generate_summary_stub() {
    local pkg
    pkg=${1}; shift
    # rest are tags separated followed by double dash followed by lines

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a tags
    tags=()
    while [[ ${#} -gt 0 ]]; do
        if [[ ${1} = '--' ]]; then
            shift
            break
        fi
        tags+=( "${1}" )
        shift
    done
    # rest are lines

    {
        printf '%s %s:' '-' "${pkg}"
        if [[ ${#tags[@]} -gt 0 ]]; then
            printf ' [%s]' "${tags[@]}"
        fi
        printf '\n'
        if [[ ${#} -gt 0 ]]; then
            printf '  - %s\n' "${@}"
            printf '\n'
        fi
    } >>"${REPORTS_DIR}/updates/summary_stubs"
}

function generate_ebuild_diff() {
    local old_ps new_ps old_pkg new_pkg old_s new_s old new
    old_ps=${1}; shift
    new_ps=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    local old_pkg_name new_pkg_name
    old_pkg_name=${old_pkg#*/}
    new_pkg_name=${new_pkg#*/}

    local old_path new_path
    old_path="${old_ps}/${old_pkg}/${old_pkg_name}-${old}.ebuild"
    new_path="${new_ps}/${new_pkg}/${new_pkg_name}-${new}.ebuild"

    local ged_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" ged_update_dir
    xdiff "${old_path}" "${new_path}" >"${ged_update_dir}/diff"
}

function generate_package_mention_reports() {
    local scripts old_pkg new_pkg old_s new_s
    scripts=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift

    local gpr_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" gpr_update_dir

    generate_mention_report_for_package "${scripts}" "${new_pkg}" >"${gpr_update_dir}/occurences"

    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        generate_mention_report_for_package "${scripts}" "${old_pkg}" >"${gpr_update_dir}/occurences-for-old-name"
    fi
}

function generate_mention_report_for_package() {
    local scripts pkg
    scripts=${1}; shift
    pkg=${1}; shift

    local ps co
    ps='sdk_container/src/third_party/portage-stable'
    co='sdk_container/src/third_party/coreos-overlay'

    yell "${pkg} in overlay profiles"
    grep_pkg "${scripts}" "${pkg}" "${co}/profiles"

    yell "${pkg} in gentoo profiles"
    grep_pkg "${scripts}" "${pkg}" "${ps}/profiles"

    # shellcheck disable=SC2164 # we use set -e, so the script will exit if it fails
    pushd "${scripts}/${co}" >/dev/null

    yell "${pkg} in env overrides"
    cat_entries "coreos/config/env/${pkg}"@(|-+([0-9])*)

    yell "${pkg} in user patches"
    local dir
    for dir in "coreos/user-patches/${pkg}"@(|-+([0-9])*); do
        echo "BEGIN DIRECTORY: ${dir}"
        cat_entries "${dir}"/*
        echo "END DIRECTORY: ${dir}"
    done

    # shellcheck disable=SC2164 # we use set -e, so the script will exit if it fails
    popd >/dev/null

    yell "${pkg} in overlay (outside profiles)"
    grep_pkg "${scripts}" "${pkg}" "${ps}" ":(exclude)${ps}/profiles"

    yell "${pkg} in gentoo (outside profiles)"
    grep_pkg "${scripts}" "${pkg}" "${co}" ":(exclude)${co}/profiles"

    yell "${pkg} in scripts"
    grep_pkg "${scripts}" "${pkg}" ":(exclude)${ps}/profiles" ":(exclude)${co}/profiles"
}

function update_dir() {
    local pkg old_s new_s dir_var_name
    pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    dir_var_name=${1}; shift
    local -n dir_ref="${dir_var_name}"

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    # slots may have slashes in them - replace them with "-slash-"
    local slot_dir
    if [[ ${old_s} = "${new_s}" ]]; then
        slot_dir="${old_s//\//-slash-}"
    else
        slot_dir="${old_s//\//-slash-}-to-${new_s//\//-slash-}"
    fi
    # shellcheck disable=SC2034 # it's a reference to external variable
    dir_ref="${REPORTS_DIR}/updates/${pkg}/${slot_dir}"
}

function grep_pkg() {
    local scripts pkg
    scripts=${1}; shift
    pkg=${1}; shift
    # rest are directories

    git -C "${scripts}" grep "${pkg}"'\(-[0-9]\|[^a-bA-Z0-9-]\|$\)' -- "${@}" || :
}

function cat_entries() {
    for entry; do
        echo "BEGIN ENTRY: ${entry}"
        cat "${entry}"
        echo "END ENTRY: ${entry}"
    done
}

function handle_gentoo_sync() {
    mvm_declare hgs_pkg_to_tags_mvm
    process_listings hgs_pkg_to_tags_mvm

    local -A hgs_renames_old_to_new_map hgs_renames_new_to_old_map
    # shellcheck disable=SC2034 # it's passed by name
    hgs_renames_old_to_new_map=()
    # shellcheck disable=SC2034 # it's passed by name
    hgs_renames_new_to_old_map=()
    load_rename_maps hgs_renames_old_to_new_map hgs_renames_new_to_old_map

    handle_package_changes hgs_renames_old_to_new_map hgs_renames_new_to_old_map hgs_pkg_to_tags_mvm

    mvm_unset hgs_pkg_to_tags_mvm

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local old_head new_head
    # shellcheck disable=SC2153 # OLD_STATE is not a misspelling
    old_head=$(git -C "${OLD_STATE}" rev-parse HEAD)
    new_head=$(git -C "${NEW_STATE}" rev-parse HEAD)

    local -A non_package_updates_set
    non_package_updates_set=()
    local path in_ps category
    if [[ "${old_head}" != "${new_head}" ]]; then
        while read -r path; do
            in_ps=${path#"${PORTAGE_STABLE_SUFFIX}/"}
            category=${in_ps%%/*}
            case "${category}" in
                eclass)
                    if [[ ${in_ps} != 'eclass/'+([^/])'.eclass' ]]; then
                        fail "unexpected updated file inside eclass directory: '${path}'"
                    fi
                    non_package_updates_set["${in_ps}"]=x
                    ;;
                licenses|metadata|profiles)
                    non_package_updates_set["${category}"]=x
                    ;;
                virtual|*-*)
                    # Package update, already handled
                    :
                    ;;
                *)
                    fail "unexpected updated file '${line}'"
                    ;;
            esac
        done < <(git -C "${NEW_STATE}" diff-tree --no-commit-id --name-only -r "${old_head}" "${new_head}")
    fi

    local entry
    for entry in "${!non_package_updates_set[@]}"; do
        case "${entry}" in
            eclass/*)
                handle_eclass "${entry}"
                ;;
            profiles)
                handle_profiles
                ;;
            licenses)
                handle_licenses
                ;;
            scripts)
                handle_scripts
                ;;
            metadata)
                fail "not handling metadata updates"
                ;;
            *)
                fail "unknown non-package update for ${entry}"
                ;;
        esac
    done
}

function handle_eclass() {
    local eclass
    eclass=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    mkdir -p "${REPORTS_DIR}/updates/${eclass}"
    local -a lines
    lines=()
    if [[ -e "${OLD_PORTAGE_STABLE}/${eclass}" ]] && [[ -e "${NEW_PORTAGE_STABLE}/${eclass}" ]]; then
        xdiff "${OLD_PORTAGE_STABLE}/${eclass}" "${NEW_PORTAGE_STABLE}/${eclass}" >"${REPORTS_DIR}/updates/${eclass}/diff"
        lines+=( 'TODO: review the diff' )
    elif [[ -e "${OLD_PORTAGE_STABLE}/${eclass}" ]]; then
        lines+=( 'unused, dropped' )
    else
        lines+=( 'added from Gentoo' )
    fi
    generate_summary_stub "${eclass}" -- "${lines[@]}"
}

function handle_profiles() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a files
    files=()
    local arch which report
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in sdk-profiles board-profiles; do
                files+=("${WORKDIR}/pkg-reports/${which}-${arch}/${report}")
            done
        done
    done
    local -A profile_dirs_set
    profile_dirs_set=()

    local line
    while read -r line; do
        profile_dirs_set["${line}"]=x
    done < <(xgrep --no-filename '^portage-stable:' "${files[@]}" | cut -d: -f2-)

    local -a diff_opts
    diff_opts=(
        --recursive
        --unified
        --new-file  # treat absent files as empty
    )

    local out_dir
    out_dir="${REPORTS_DIR}/updates/profiles"
    mkdir -p "${out_dir}"

    xdiff "${diff_opts[@]}" \
         "${OLD_PORTAGE_STABLE}/profiles" "${NEW_PORTAGE_STABLE}/profiles" >"${out_dir}/full-diff"

    local relevant
    relevant=''
    local -a relevant_lines possibly_irrelevant_files
    relevant_lines=()
    possibly_irrelevant_files=()
    local path dir mark
    while read -r line; do
        if [[ ${line} = "diff ${diff_opts[*]} "* ]]; then
            path=${line##*"${NEW_PORTAGE_STABLE}/profiles/"}
            dirname_out "${path}" dir
            relevant=''
            mark=${profile_dirs_set["${dir}"]:-}
            if [[ -n "${mark}" ]]; then
                relevant=x
            else
                case ${dir} in
                    .|desc|desc/*|updates|updates/*)
                        relevant=x
                        ;;
                esac
            fi
            if [[ -z ${relevant} ]]; then
                possibly_irrelevant_files+=( "profiles/${path}" )
            fi
        fi
        if [[ -n ${relevant} ]]; then
            relevant_lines+=( "${line}" )
        fi
    done <"${out_dir}/full-diff"
    lines_to_file_truncate "${out_dir}/relevant-diff" "${relevant_lines[@]}"
    lines_to_file_truncate "${out_dir}/possibly-irrelevant-files" "${possibly_irrelevant_files[@]}"
    generate_summary_stub profiles -- 'TODO: review the diffs'
}

function handle_licenses() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a dropped added changed
    dropped=()
    added=()
    changed=()

    local line hl_stripped
    # Lines are:
    #
    # Only in <PORTAGE_STABLE_X>/licenses: BSL-1.1
    #
    # or
    #
    # Files <PORTAGE_STABLE_1>/licenses/BSL-1.1 and <PORTAGE_STABLE_2>/licenses/BSL-1.1 differ
    while read -r line; do
        if [[ ${line} = 'Only in '* ]]; then
            # shellcheck disable=SC2153 # OLD_STATE is not a misspelling, it comes from globals file
            strip_out "${line##*:}" hl_stripped
            if [[ ${line} = *"${OLD_STATE}"* ]]; then
                dropped+=( "${hl_stripped}" )
            elif [[ ${line} = *"${NEW_STATE}"* ]]; then
                added+=( "${hl_stripped}" )
            else
                devel_warn "- unhandled license change: ${line}"
            fi
        elif [[ ${line} = 'Files '*' differ' ]]; then
            line=${line##"Files ${OLD_PORTAGE_STABLE}/licenses/"}
            line=${line%% *}
            strip_out "${line}" hl_stripped
            changed+=( "${hl_stripped}" )
        else
            devel_warn \
                '- unhandled diff --brief line:' \
                "  - ${line}"
        fi
    done < <(xdiff --brief --recursive "${OLD_PORTAGE_STABLE}/licenses" "${NEW_PORTAGE_STABLE}/licenses")

    local out_dir
    out_dir="${REPORTS_DIR}/updates/licenses"
    mkdir -p "${out_dir}"

    lines_to_file_truncate \
        "${out_dir}/brief-diff" \
        '- removed:' \
        "${dropped[@]/#/  - }" \
        '- added:' \
        "${added[@]/#/  - }" \
        '- modified:' \
        "${changed[@]/#/  - }"
    truncate --size=0 "${out_dir}/mod-diff"

    local c
    for c in "${changed[@]}"; do
        xdiff "${OLD_PORTAGE_STABLE}/licenses/${c}" "${NEW_PORTAGE_STABLE}/licenses/${c}" >>"${out_dir}/mod-diff"
    done
    local -a lines
    lines=()

    local joined
    if [[ ${#dropped[@]} -gt 0 ]]; then
        join_by joined ', ' "${dropped[@]}"
        lines+=( "dropped ${joined}" )
    fi
    if [[ ${#added[@]} -gt 0 ]]; then
        join_by joined ', ' "${added[@]}"
        lines+=( "added ${joined}" )
    fi
    if [[ ${#changed[@]} -gt 0 ]]; then
        join_by joined ', ' "${changed[@]}"
        lines+=( "updated ${joined}" )
    fi
    generate_summary_stub licenses -- "${lines[@]}"
}

function handle_scripts() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local out_dir
    out_dir="${REPORTS_DIR}/updates/scripts"
    mkdir -p "${out_dir}"

    xdiff --unified --recursive "${OLD_PORTAGE_STABLE}/scripts" "${NEW_PORTAGE_STABLE}/scripts" >"${out_dir}"
    # TODO: update summary stubs
}

function xdiff() {
    diff "${@}" || :
}

function xgrep() {
    grep "${@}" || :
}
