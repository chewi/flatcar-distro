#!/bin/bash

#
# TODO:
#
# - Generate a report about missing build deps of board packages in
#   sdk. These reports can be generated by processing sdk-pkgs-kv and
#   board-bdeps reports, I think.
#
# - Mount Gentoo repo into the SDK container and set up emerge to use
#   Gentoo as a primary repo, and portage-stable and coreos-overlay as
#   overlays. That way if an updated package pulls in a new package we
#   can notice it when it comes from Gentoo (emerge reports also
#   source repo like sys-libs/glibc-2.35-r5::gentoo or something like
#   this). This would make this script more robust.
#

source "$(dirname "${BASH_SOURCE[0]}")/stuff.sh"

# Needed to be enabled here to parse some globs inside the functions.
shopt -s extglob
# Saner defaults.
shopt -s nullglob
shopt -s dotglob

# Creates a workdir, the path to which is stored in WORKDIR global
# variable. Copies listings from the listings directory to work
# directory.
#
# 1 - directory with listings
# 2 - predefined work directory path (optional)
function setup_workdir() {
    local listings_dir workdir
    listings_dir=${1}; shift
    workdir=${1:-}
    if [[ -z "${workdir}" ]]; then
        workdir=$(mktemp --tmpdir --directory "up-XXXXXXXX")
    fi

    declare -g WORKDIR
    WORKDIR=$(realpath "${workdir}")
    add_cleanup "rmdir ${WORKDIR@Q}"
    mkdir -p "${WORKDIR}"

    setup_initial_globals_file
    copy_listings "${listings_dir}"
}

# Sets up worktrees for the old and new state inside WORKDIR. Creates
# the globals file inside WORKDIR.
#
# 1 - path to scripts repo
# 2 - base for the new worktrees (e.g. origin/main)
# 3 - path to Gentoo repo
# 4 - path to reports directory
function setup_worktrees_in_workdir() {
    local scripts scripts_base gentoo reports_dir
    scripts=${1}; shift
    scripts_base=${1}; shift
    gentoo=${1}; shift
    reports_dir=${1}; shift

    local old_state new_state
    old_state="${WORKDIR}/old_state"
    new_state="${WORKDIR}/new_state"

    setup_worktrees "${scripts}" "${scripts_base}" "old-state-${RANDOM}" "${old_state}" "new-state-${RANDOM}" "${new_state}"
    extend_globals_file "${scripts}" "${gentoo}" "${old_state}" "${new_state}" "${reports_dir}"
}

function override_sdk_image_names() {
    local overrides_map_var_name
    overrides_map_var_name=${1}; shift
    local -n overrides_map_ref="${overrides_map_var_name}"

    local globals_file
    globals_file="${WORKDIR}/globals"
    if [[ ! -e "${globals_file}" ]]; then
        fail "globals not set yet in workdir"
    fi

    if [[ ${#overrides_map_ref[@]} -eq 0 ]]; then
        return 0
    fi

    local arch image_name upcase_arch
    local -a lines
    lines=()
    for arch in "${!overrides_map_ref[@]}"; do
        image_name=${overrides_map_ref["${arch}"]}
        upcase_arch=${arch^^}
        if [[ ${#lines[@]} -eq 0 ]]; then
            # separate overrides from initial values
            lines+=( '' )
        fi
        lines+=( "${upcase_arch@Q}_PACKAGES_IMAGE=${image_name@Q}" )
    done
    lines_to_file "${globals_file}" "${lines[@]}"
}

# Goes over the list of automatically updated packages and synces them
# with packages from Gentoo repo. Cleans up missing packages.
function perform_sync_with_gentoo() {
    local -a pswg_non_package_updates pswg_missing_in_scripts pswg_missing_in_gentoo
    # shellcheck disable=SC2034 # it's passed by name
    pswg_non_package_updates=()
    pswg_missing_in_scripts=()
    pswg_missing_in_gentoo=()

    local -A pswg_renamed_old_to_new_map pswg_renamed_new_to_old_map
    # shellcheck disable=SC2034 # it's passed by name
    pswg_renamed_old_to_new_map=()
    # shellcheck disable=SC2034 # it's passed by name
    pswg_renamed_new_to_old_map=()

    run_sync pswg_non_package_updates pswg_missing_in_scripts pswg_missing_in_gentoo
    handle_missing_in_scripts "${pswg_missing_in_scripts[@]}"
    handle_missing_in_gentoo pswg_renamed_old_to_new_map pswg_renamed_new_to_old_map "${pswg_missing_in_gentoo[@]}"

    save_non_package_updates "${non_package_updates_var_name[@]}"
    save_rename_maps pswg_renamed_old_to_new_map pswg_renamed_new_to_old_map
}

# Spawns SDK containers to generate some reports using emerge and
# other tools. Processes listings. Loads saved non-package updates and
# rename maps.  Using the emerge&co reports, listing data and loaded
# data, generates package updates reports.
function generate_package_update_reports() {
    generate_sdk_reports

    mvm_declare gpur_pkg_to_tags_mvm
    process_listings gpur_pkg_to_tags_mvm

    # shellcheck disable=SC2034 # it's passed by name
    local -a gpur_non_package_updates
    gpur_non_package_updates=()
    load_non_package_updates gpur_non_package_updates

    # shellcheck disable=SC2034 # it's passed by name
    local -A gpur_renames_old_to_new_map gpur_renames_new_to_old_map
    gpur_renames_old_to_new_map=()
    gpur_renames_new_to_old_map=()
    load_rename_maps gpur_renames_old_to_new_map gpur_renames_new_to_old_map

    handle_gentoo_sync gpur_non_package_updates gpur_renames_old_to_new_map gpur_renames_new_to_old_map gpur_pkg_to_tags_mvm

    mvm_unset gpur_pkg_to_tags_mvm
}

# Saves the new state to a given branch in scripts.
#
# 1 - a branch name to create
function save_new_state() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local branch
    branch=${1}; shift
    # shellcheck disable=SC2153 # SCRIPTS and NEW_STATE_BRANCH are not misspellings, they come from globals file
    git -C "${SCRIPTS}" branch "${branch}" "${NEW_STATE_BRANCH}"
}

# details

function save_non_package_updates() {
    add_cleanup "rm -f ${WORKDIR@Q}/non-package-updates"
    if [[ ${#} -eq 0 ]]; then
        touch "${WORKDIR}/non-package-updates"
    else
        printf '%s\n' "${@}" | sort >"${WORKDIR}/non-package-updates"
    fi
}

function load_non_package_updates() {
    local non_package_updates_var_name
    non_package_updates_var_name=${1}; shift

    if [[ ! -e "${WORKDIR}/non-package-updates" ]]; then
        fail "non-package updates were not saved"
    fi

    mapfile -t "${non_package_updates_var_name}" <"${WORKDIR}/non-package-updates"
}

function save_rename_maps() {
    local old_to_new_map_var_name new_to_old_map_var_name
    old_to_new_map_var_name=${1}; shift
    new_to_old_map_var_name=${1}; shift
    local -n old_to_new_map_ref="${old_to_new_map_var_name}"
    local -n new_to_old_map_ref="${new_to_old_map_var_name}"

    local item mapped other_mapped
    for item in "${!old_to_new_map_ref[@]}"; do
        mapped=${old_to_new_map_ref["${item}"]}
        other_mapped=${new_to_old_map_ref["${mapped}"]:-}
        if [[ -z "${other_mapped}" ]]; then
            fail "rename maps inconsistency, missing '${mapped}' from new to old map"
        fi
    done
    for item in "${!new_to_old_map_ref[@]}"; do
        mapped=${new_to_old_map_ref["${item}"]}
        other_mapped=${old_to_new_map_ref["${mapped}"]:-}
        if [[ -z "${other_mapped}" ]]; then
            fail "rename maps inconsistency, missing '${mapped}' from new to old map"
        fi
    done

    add_cleanup "rm -f ${WORKDIR@Q}/rename-map"
    {
        for item in "${!old_to_new_map_ref[@]}"; do
            mapped=${old_to_new_map_ref["${item}"]}
            printf '%s:%s\n' "${item}" "${mapped}"
        done
    } >"${WORKDIR}/rename-map"
}

function load_rename_maps() {
    local old_to_new_map_var_name new_to_old_map_var_name
    old_to_new_map_var_name=${1}; shift
    new_to_old_map_var_name=${1}; shift
    local -n old_to_new_map_ref="${old_to_new_map_var_name}"
    local -n new_to_old_map_ref="${new_to_old_map_var_name}"

    if [[ ! -e "${WORKDIR}/rename-map" ]]; then
        fail "rename maps were not saved"
    fi

    old_to_new_map_ref=()
    new_to_old_map_ref=()

    local old new
    while read -r line; do
        old=${line%%:*}
        new=${line##*:}
        old_to_new_map_ref["${old}"]=${new}
        new_to_old_map_ref["${new}"]=${old}
    done <"${WORKDIR}/rename-map"
}

function setup_worktrees() {
    local scripts scripts_base old_state_branch old_state new_state_branch new_state
    scripts=${1}; shift
    scripts_base=${1}; shift
    old_state_branch=${1}; shift
    old_state=${1}; shift
    new_state_branch=${1}; shift
    new_state=${1}; shift

    add_cleanup \
        "git -C ${old_state@Q} reset --hard HEAD" \
        "git -C ${old_state@Q} clean -ffdx" \
        "git -C ${new_state@Q} reset --hard HEAD" \
        "git -C ${new_state@Q} clean -ffdx" \
        "git -C ${scripts@Q} worktree remove ${old_state@Q}" \
        "git -C ${scripts@Q} worktree remove ${new_state@Q}" \
        "git -C ${scripts@Q} branch -D ${old_state_branch@Q}" \
        "git -C ${scripts@Q} branch -D ${new_state_branch@Q}"

    git -C "${scripts}" worktree add -b "${old_state_branch}" "${old_state}" "${scripts_base}"
    git -C "${scripts}" worktree add -b "${new_state_branch}" "${new_state}" "${scripts_base}"
}

function setup_initial_globals_file() {
    local globals_file
    globals_file="${WORKDIR}/globals"
    add_cleanup "rm -f ${globals_file@Q}"
    cat <<EOF >"${globals_file}"
local -a GIT_ENV_VARS ARCHES WHICH REPORTS
local -A LISTING_KINDS
local SDK_PKGS BOARD_PKGS

GIT_ENV_VARS=(
    GIT_{AUTHOR,COMMITTER}_{NAME,EMAIL}
)

ARCHES=(amd64 arm64)
WHICH=(old new)
SDK_PKGS=sdk-pkgs
BOARD_PKGS=board-pkgs
REPORTS=( "\${SDK_PKGS}" "\${BOARD_PKGS}" )

LISTING_KINDS=(
    ['prod']='flatcar_production_image_packages.txt'
    ['dev']='flatcar_developer_container_packages.txt'
)
EOF
}

function extend_globals_file() {
    local scripts gentoo old_state new_state reports_dir
    scripts=${1}; shift
    gentoo=${1}; shift
    old_state=${1}; shift
    new_state=${1}; shift
    reports_dir=${1}; shift

    local globals_file
    globals_file="${WORKDIR}/globals"
    if [[ ! -e "${globals_file}" ]]; then
        fail 'an initial version of globals file should already exist'
    fi

    local old_state_branch new_state_branch
    old_state_branch=$(git -C "${old_state}" rev-parse --abbrev-ref HEAD)
    new_state_branch=$(git -C "${new_state}" rev-parse --abbrev-ref HEAD)

    local portage_stable_suffix old_portage_stable new_portage_stable
    portage_stable_suffix='sdk_container/src/third_party/portage-stable'
    old_portage_stable="${old_state}/${portage_stable_suffix}"
    new_portage_stable="${new_state}/${portage_stable_suffix}"

    cat <<EOF >>"${globals_file}"
local SCRIPTS GENTOO OLD_STATE NEW_STATE OLD_STATE_BRANCH NEW_STATE_BRANCH
local PORTAGE_STABLE_SUFFIX OLD_PORTAGE_STABLE NEW_PORTAGE_STABLE REPORTS_DIR

SCRIPTS=${scripts@Q}
GENTOO=${gentoo@Q}
OLD_STATE=${old_state@Q}
NEW_STATE=${new_state@Q}
OLD_STATE_BRANCH=${old_state_branch@Q}
NEW_STATE_BRANCH=${new_state_branch@Q}
PORTAGE_STABLE_SUFFIX=${portage_stable_suffix@Q}
OLD_PORTAGE_STABLE=${old_portage_stable@Q}
NEW_PORTAGE_STABLE=${new_portage_stable@Q}
REPORTS_DIR=${reports_dir@Q}
EOF
}

# make sure to call the following beforehand:
#
# local -x "${GIT_ENV_VARS[@]}"
function setup_git_env() {
    local bot_name bot_email role what

    # shellcheck disable=SC2034 # used indirectly
    bot_name='Flatcar Buildbot'
    # shellcheck disable=SC2034 # used indirectly
    bot_email='buildbot@flatcar-linux.org'
    for role in AUTHOR COMMITTER; do
        for what in name email; do
            local -n var="GIT_${role}_${what^^}"
            local -n value="bot_${what}"
            # shellcheck disable=SC2034 # it's a reference to external variable
            var=${value}
            unset -n value
            unset -n var
        done
    done
}

function run_sync() {
    local non_package_updates_var_name missing_in_scripts_var_name missing_in_gentoo_var_name
    non_package_updates_var_name=${1}; shift
    local -n non_package_updates_ref="${non_package_updates_var_name}"
    missing_in_scripts_var_name=${1}; shift
    local -n missing_in_scripts_ref="${missing_in_scripts_var_name}"
    missing_in_gentoo_var_name=${1}; shift
    local -n missing_in_gentoo_ref="${missing_in_gentoo_var_name}"

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -x "${GIT_ENV_VARS[@]}"
    setup_git_env

    local packages_list sync_script new_head
    # shellcheck disable=SC2153 # NEW_STATE is not a misspelling, it comes from globals file
    packages_list="${NEW_STATE}/.github/workflows/portage-stable-packages-list"
    sync_script="${THIS_DIR}/sync_with_gentoo.sh"
    new_head=$(git -C "${NEW_STATE}" rev-parse HEAD)
    local package old_head line category
    local -A non_package_updates_set
    non_package_updates_set=()
    while read -r package; do
        old_head=${new_head}
        # shellcheck disable=SC2153 # NEW_PORTAGE_STABLE is not a misspelling, it comes from globals file
        if [[ ! -e "${NEW_PORTAGE_STABLE}/${package}" ]]; then
            # If this happens, it means that the package was moved to overlay
            # or dropped, the list ought to be updated.
            missing_in_scripts_ref+=("${package}")
            continue
        fi
        # shellcheck disable=SC2153 # GENTOO is not a misspelling, it comes from globals file
        if [[ ! -e "${GENTOO}/${package}" ]]; then
            # If this happens, it means that the package was obsoleted or moved
            # in Gentoo. The obsoletion needs to be handled in the case-by-case
            # manner, while move should be handled by doing the same move
            # in portage-stable. The build should not break because of the move,
            # because most likely it's already reflected in the profiles/updates
            # directory.
            missing_in_gentoo_ref+=("${package}")
            continue
        fi
        env --chdir="${NEW_PORTAGE_STABLE}" "${sync_script}" "${GENTOO}" "${package}"
        new_head=$(git -C "${NEW_STATE}" rev-parse HEAD)
        if [[ "${old_head}" != "${new_head}" ]]; then
            while read -r line; do
                line=${line#"${PORTAGE_STABLE_SUFFIX}/"}
                category=${line%%/*}
                case "${category}" in
                    eclass|licenses|metadata|profiles)
                        non_package_updates_set["${category}"]=x
                        ;;
                    virtual|*-*)
                        # Package update, will be handled separately.
                        :
                        ;;
                    *)
                        fail "unexpected updated file '${line}'"
                        ;;
                esac
            done < <(git -C "${NEW_STATE}" diff-tree --no-commit-id --name-only HEAD -r)
        fi
    done < <(xgrep '^[^#]' "${packages_list}")
    # shellcheck disable=SC2034 # it's a reference to external variable
    non_package_updates_ref=( "${!non_package_updates_set[@]}" )
}

function handle_missing_in_scripts() {
    # all the args are missing packages

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    if [[ ${#} -eq 0 ]]; then
        return 0;
    fi

    local packages_list_sort
    packages_list_sort="${THIS_DIR}/sort_packages_list.py"
    local packages_list
    packages_list="${NEW_STATE}/.github/workflows/portage-stable-packages-list"

    # Remove missing in scripts entries from package automation
    local dir
    dir="${WORKDIR}/missing_in_scripts"
    add_cleanup "rmdir ${dir@Q}"
    mkdir "${dir}"
    local missing_re
    join_by missing_re '\|' "${missing_in_scripts_ref[@]}"
    add_cleanup "rm -f ${dir@Q}/pkg_list"
    xgrep --invert-match --line-regexp --regexp="${missing_re}" "${packages_list}" >"${dir}/pkg_list"
    "${packages_list_sort}" "${dir}/pkg_list" >"${packages_list}"

    local -x "${GIT_ENV_VARS[@]}"
    setup_git_env

    git -C "${NEW_STATE}" add "${packages_list}"
    git -C "${NEW_STATE}" commit -m '.github: Drop missing packages from automation'
}

function lines_to_file_truncate() {
    printf '%s\n' "${@:2}" >"${1}"
}

function lines_to_file() {
    printf '%s\n' "${@:2}" >>"${1}"
}

function manual() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    # shellcheck disable=SC2153 # REPORTS_DIR is not a misspelling, it comes from globals file
    lines_to_file "${REPORTS_DIR}/manual-work-needed" "${@}"
}

function pkg_warn() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    lines_to_file "${REPORTS_DIR}/warnings" "${@}"
}

function devel_warn() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    lines_to_file "${REPORTS_DIR}/developer-warnings" "${@}"
}

function handle_missing_in_gentoo() {
    local renamed_old_to_new_map_var_name renamed_new_to_old_map_var_name
    renamed_old_to_new_map_var_name=${1}; shift
    local -n renamed_old_to_new_map_ref="${renamed_old_to_new_map_var_name}"
    renamed_new_to_old_map_var_name=${1}; shift
    local -n renamed_new_to_old_map_ref="${renamed_new_to_old_map_var_name}"
    # the rest are packages missing in Gentoo

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    if [[ ${#} -eq 0 ]]; then
        return 0
    fi

    local packages_list_sort
    packages_list_sort="${THIS_DIR}/sort_packages_list.py"
    local packages_list
    packages_list="${NEW_STATE}/.github/workflows/portage-stable-packages-list"

    local -a renamed_from renamed_to
    renamed_from=()
    renamed_to=()

    local sync_script
    sync_script="${THIS_DIR}/sync_with_gentoo.sh"

    local -x "${GIT_ENV_VARS[@]}"
    setup_git_env

    local missing new_name old_basename new_basename ebuild ebuild_version_ext new_ebuild_filename
    for missing; do
        new_name=$(xgrep --recursive --regexp="^move ${missing} " "${NEW_PORTAGE_STABLE}/profiles/updates/" | cut -d' ' -f3)
        if [[ -z "${new_name}" ]]; then
            manual "- package ${missing} is gone from Gentoo and no rename found"
            continue
        fi
        mkdir -p "${NEW_PORTAGE_STABLE}/${new_name%/*}"
        git -C "${NEW_STATE}" mv "${NEW_PORTAGE_STABLE}/${missing}" "${NEW_PORTAGE_STABLE}/${new_name}"
        basename_out "${missing}" old_basename
        basename_out "${new_name}" new_basename
        if [[ "${old_basename}" != "${new_basename}" ]]; then
            for ebuild in "${NEW_PORTAGE_STABLE}/${new_name}/${old_basename}-"*'.ebuild'; do
                # 1.2.3-r4.ebuild
                ebuild_version_ext=${ebuild##*/"${old_basename}-"}
                new_ebuild_filename="${new_basename}-${ebuild_version_ext}"
                git -C "${NEW_STATE}" mv "${ebuild}" "${NEW_PORTAGE_STABLE}/${new_name}/${new_ebuild_filename}"
            done
        fi
        git -C "${NEW_STATE}" commit "${new_name}: Renamed from ${missing}"
        env --chdir="${NEW_PORTAGE_STABLE}" "${sync_script}" "${GENTOO}" "${new_name}"
        renamed_from+=("${missing}")
        renamed_to+=("${new_name}")
        renamed_new_to_old_map_ref["${new_name}"]="${missing}"
        renamed_old_to_new_map_ref["${missing}"]="${new_name}"
    done

    local dir renamed_re
    if [[ ${#renamed_from[@]} -gt 0 ]]; then
        dir="${WORKDIR}/missing_in_gentoo"
        add_cleanup "rmdir ${dir@Q}"
        mkdir "${dir}"
        join_by renamed_re '\|' "${renamed_from[@]}"
        add_cleanup "rm -f ${dir@Q}/pkg_list"
        {
            xgrep --invert-match --line-regexp --regexp="${renamed_re}" "${packages_list}"
            printf '%s\n' "${renamed_to[@]}"
        } >"${dir}/pkg_list"
        "${packages_list_sort}" "${dir}/pkg_list" >"${packages_list}"
        git -C "${NEW_STATE}" add "${packages_list}"
        git -C "${NEW_STATE}" commit -m '.github: Update package names in automation'
    fi
}

function copy_listings() {
    local listings_dir
    listings_dir=${1}; shift;

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    add_cleanup "rmdir ${WORKDIR@Q}/listings"
    mkdir "${WORKDIR}/listings"
    local arch kind listing_name source_listing target_listing
    for arch in "${ARCHES[@]}"; do
        for kind in "${!LISTING_KINDS[@]}"; do
            listing_name=${LISTING_KINDS["${kind}"]}
            source_listing="${listings_dir}/${arch}/${listing_name}"
            target_listing="${WORKDIR}/listings/${arch}-${kind}"
            if [[ -e "${source_listing}" ]]; then
                add_cleanup "rm -f ${target_listing@Q}"
                cp -a "${source_listing}" "${target_listing}"
            else
                fail "No listing for ${kind} on ${arch} available in ${listings_dir}"
            fi
        done
    done
}

function process_listings() {
    local pkg_to_tags_mvm_var_name
    pkg_to_tags_mvm_var_name=${1}

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local eclass ver_ere pkg_ere
    eclass="${THIS_DIR}/../${PORTAGE_STABLE_SUFFIX}/eclass/eapi7-ver.eclass"
    # line is like '   re="<regexp>"'
    ver_ere=$(grep -e 're=' "${eclass}" || fail "no 're=' line found in eapi7-ver.eclass")
    if [[ -z ${ver_ere} ]]; then
        fail 'empty version regex from eapi7-ver.eclass'
    fi
    # strip everything until first quotes
    ver_ere=${ver_ere#*'"'}
    # strip last quote
    ver_ere=${ver_ere%'"'*}
    # regexp begins with ^ and ends with $, so strip them too
    ver_ere=${ver_ere#'^'}
    ver_ere=${ver_ere#'$'}
    pkg_ere='[a-z0-9]*-\?[a-z0-9]*/[a-z0-9A-Z_+-]*'

    mvm_declare pl_pkg_to_tags_set_mvm mvm_mvc_set

    local arch kind listing pkg
    for arch in "${ARCHES[@]}"; do
        for kind in "${!LISTING_KINDS[@]}"; do
            listing="${WORKDIR}/listings/${arch}-${kind}"
            # lines are like as follows:
            #
            # acct-group/adm-0-r2::portage-stable
            while read -r pkg; do
                mvm_add pl_pkg_to_tags_set_mvm "${pkg}" "${kind^^}"
            done < <(sed -E -e 's#^('"${pkg_ere}"')-'"${ver_ere}"'::.*#\1#' "${listing}")
        done
    done

    mvm_iterate pl_pkg_to_tags_set_mvm set_mvm_to_array_mvm_cb "${pkg_to_tags_mvm_var_name}"
    mvm_unset pl_pkg_to_tags_set_mvm
}

function set_mvm_to_array_mvm_cb() {
    local pkg_to_tags_mvm_var_name pkg set_var_name
    pkg_to_tags_mvm_var_name=${1}; shift
    pkg=${1}; shift
    set_var_name=${1}; shift
    local -n set_ref="${set_var_name}"
    # rest are set items

    local removed
    removed=''
    local -a prod_item
    prod_item=()
    if [[ -n ${set_ref['prod']:-} ]]; then
        prod_item+=('prod')
        unset "set_ref['prod']"
        removed=x
    fi
    local -a sorted_items
    mapfile -t sorted_items < <(printf '%s\n' "${!set_ref[@]}" | sort)
    if [[ -n ${removed} ]]; then
        set_ref['prod']=x
    fi

    mvm_add "${pkg_to_tags_mvm_var_name}" "${pkg}" "${prod_item[@]}" "${sorted_items[@]}"
}

function generate_sdk_reports() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local last_nightly_version_id last_nightly_build_id
    # shellcheck disable=SC1091 # sourcing generated file
    last_nightly_version_id=$(source "${NEW_STATE}/sdk_container/.repo/manifests/version.txt"; printf '%s' "${FLATCAR_VERSION_ID}")
    # shellcheck disable=SC1091 # sourcing generated file
    last_nightly_build_id=$(source "${NEW_STATE}/sdk_container/.repo/manifests/version.txt"; printf '%s' "${FLATCAR_BUILD_ID}")

    add_cleanup "rmdir ${WORKDIR@Q}/pkg-reports"
    mkdir "${WORKDIR}/pkg-reports"

    local arch packages_image_var_name packages_image_name
    local sdk_run_kind state_var_name sdk_run_state state_branch_var_name sdk_run_state_branch
    local file full_file
    local rv
    local sdk_reports_dir
    local -a report_files
    for arch in "${ARCHES[@]}"; do
        packages_image_var_name="${arch^^}_PACKAGES_IMAGE"
        local -n packages_image_ref="${packages_image_var_name}"
        packages_image_name=${packages_image_ref:-"flatcar-packages-${arch}:${last_nightly_version_id}-${last_nightly_build_id}"}
        unset -n packages_image_ref
        if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep --quiet --line-regexp --fixed-strings "${packages_image_name}"; then
            fail "No SDK image named '${packages_image_name}' available locally, pull it before running this script"
        fi

        # shellcheck disable=SC2153 # WHICH is not a misspelling, it comes from globals file
        for sdk_run_kind in "${WHICH[@]}"; do
            state_var_name="${sdk_run_kind^^}_STATE"
            sdk_run_state="${!state_var_name}_sdk_run_${arch}"
            state_branch_var_name="${sdk_run_kind^^}_STATE_BRANCH"
            sdk_run_state_branch="${!state_branch_var_name}-sdk-run-${arch}"

            add_cleanup \
                "git -C ${sdk_run_state@Q} reset --hard HEAD" \
                "git -C ${sdk_run_state@Q} clean -ffdx" \
                "git -C ${SCRIPTS@Q} worktree remove ${sdk_run_state@Q}" \
                "git -C ${SCRIPTS@Q} branch -D ${sdk_run_state_branch@Q}"
            git -C "${SCRIPTS}" \
                worktree add -b "${sdk_run_state_branch}" "${sdk_run_state}" "${!state_branch_var_name}"
            for file in inside_sdk_container.sh stuff.sh print_profile_tree.sh; do
                full_file="${sdk_run_state}/${file}"
                add_cleanup "rm -f ${full_file@Q}"
                cp -a "${THIS_DIR}/${file}" "${sdk_run_state}"
            done
            rv=0
            env --chdir "${sdk_run_state}" \
                ./run_sdk_container \
                -C "${packages_image_name}" \
                -n "pkg-${sdk_run_kind}-${arch}" \
                -a "${arch}" \
                --rm \
                ./inside_sdk_container.sh "${arch}" pkg-reports || rv=${?}
            if [[ ${rv} -ne 0 ]]; then
                {
                    info "run_sdk_container finished with exit status ${rv}, printing the warnings below for a clue"
                    for file in "${sdk_run_state}/pkg-reports/"*'-warnings'; do
                        info "from ${file}:"
                        echo
                        cat "${file}"
                        echo
                    done
                } >&2
                fail "stopping"
            fi
            sdk_reports_dir="${WORKDIR}/pkg-reports/${sdk_run_kind}-${arch}"
            report_files=()
            for full_file in "${sdk_run_state}/pkg-reports/"*; do
                file=${full_file##"${sdk_run_state}/pkg-reports/"}
                report_files+=( "${sdk_reports_dir}/${file}" )
            done
            add_cleanup \
                "rm -f ${report_files[*]@Q}" \
                "rmdir ${sdk_reports_dir@Q}"
            mv "${sdk_run_state}/pkg-reports" "${sdk_reports_dir}"
        done
    done
    cp -a "${WORKDIR}/pkg-reports" "${REPORTS_DIR}/reports-from-sdk"
}

source "${THIS_DIR}/mvm.sh"

# pkginfo: map[pkg]map[slot]version
function pkginfo_name() {
    local which arch report pi_name_var_name

    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift
    pi_name_var_name=${1}; shift
    local -n pi_name_ref="${pi_name_var_name}"

    # shellcheck disable=SC2034 # it's a reference to external variable
    pi_name_ref="pkginfo_${which}_${arch}_${report//-/_}_pimap_mvm"
}

function pkginfo_constructor() {
    mvm_mvc_map_constructor "${@}"
}

function pkginfo_destructor() {
    mvm_mvc_map_destructor "${@}"
}

function pkginfo_adder() {
    local map_var_name
    map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n map_ref="${map_var_name}"

    local mark
    while [[ ${#} -gt 1 ]]; do
        mark=${map_ref["${1}"]:-}
        if [[ -n "${mark}" ]]; then
            fail "multiple versions for a single slot for a package in a single report"
        fi
        map_ref["${1}"]=${2}
        shift 2
    done
}

function pkginfo_declare() {
    local which arch report pi_name_var_name
    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift
    pi_name_var_name=${1}; shift

    pkginfo_name "${which}" "${arch}" "${report}" "${pi_name_var_name}"

    local -a extras
    extras=(
        'which' "${which}"
        'arch' "${arch}"
        'report' "${report}"
    )

    mvm_declare "${!pi_name_var_name}" pkginfo -- "${extras[@]}"
}

function pkginfo_unset() {
    local which arch report
    which=${1}; shift
    arch=${1}; shift
    report=${1}; shift

    local piu_pi_name
    pkginfo_name "${which}" "${arch}" "${report}" piu_pi_name

    mvm_unset "${piu_pi_name}"
}

function pkginfo_process_file() {
    mvm_call "${1}" pkginfo_c_process_file "${@:2}"
}

function pkginfo_c_process_file() {
    local pkg_set_var_name pkg_slots_set_mvm_var_name
    pkg_set_var_name=${1}; shift
    local -n pkg_set_ref="${pkg_set_var_name}"
    pkg_slots_set_mvm_var_name=${1}; shift

    local which arch report
    mvm_c_get_extra 'which' which
    mvm_c_get_extra 'arch' arch
    mvm_c_get_extra 'report' report

    local pkg version_slot throw_away v s
    # shellcheck disable=SC2034 # throw_away is unused, it's here for read to store the rest of the line if there is something else
    while read -r pkg version_slot throw_away; do
        v=${version_slot%%:*}
        s=${version_slot##*:}
        mvm_c_add "${pkg}" "${s}" "${v}"
        # shellcheck disable=SC2034 # it's a reference to external variable
        pkg_set_ref["${pkg}"]='x'
        mvm_add "${pkg_slots_set_mvm_var_name}" "${pkg}" "${s}"
    done <"${WORKDIR}/pkg-reports/${which}-${arch}/${report}"
}

function pkginfo_profile() {
    mvm_call "${1}" pkginfo_c_profile "${@:2}"
}

function pkginfo_c_profile() {
    local profile_var_name
    profile_var_name=${1}; shift

    local which arch report
    mvm_c_get_extra 'which' which
    mvm_c_get_extra 'arch' arch
    mvm_c_get_extra 'report' report

    printf -v "${profile_var_name}" '%s-%s-%s' "${which}" "${arch}" "${report}"
}

function read_reports() {
    local all_pkgs_var_name pkg_slots_set_mvm_var_name
    all_pkgs_var_name=${1}; shift
    pkg_slots_set_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -A all_packages_set
    all_packages_set=()

    local arch which report rr_pimap_mvm_var_name
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in "${REPORTS[@]}"; do
                pkginfo_declare "${which}" "${arch}" "${report}" rr_pimap_mvm_var_name
                pkginfo_process_file "${rr_pimap_mvm_var_name}" all_packages_set "${pkg_slots_set_mvm_var_name}"
            done
        done
    done
    local -n all_pkgs_ref="${all_pkgs_var_name}"
    all_pkgs_ref=( "${!all_packages_set[@]}" )
}

function unset_report_mvms() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local arch which report
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in "${REPORTS[@]}"; do
                pkginfo_unset "${which}" "${arch}" "${report}"
            done
        done
    done
}

###
### BEGIN GENTOO VER COMP HACKS
###

# shellcheck disable=SC2034 # it's here only for the eapi7-ver.eclass
EAPI=6
function die() {
    fail "$*"
}

# shellcheck disable=SC1091 # sourcing external file
source "${THIS_DIR}/../sdk_container/src/third_party/portage-stable/eclass/eapi7-ver.eclass"

unset EAPI

function gentoo_ver_test_out() {
    local v1 op v2 out_var_name
    v1=${1}; shift
    op=${1}; shift
    v2=${1}; shift
    out_var_name=${1}; shift
    local -n out_ref="${out_var_name}"

    out_ref=0
    ver_test "${v1}" "${op}" "${v2}" || out_ref=${?}
    return 0
}

function gentoo_ver_test() {
    local v1 op v2
    v1=${1}; shift
    op=${1}; shift
    v2=${1}; shift

    local gvt_retval
    gentoo_ver_test_out "${v1}" "${op}" "${v2}" gvt_retval
    return "${gvt_retval}"
}

# symbolic names for use with gentoo_ver_cmp
GV_LT=1
GV_EQ=2
GV_GT=3

# 1 - version 1
# 2 - version 2
# 3 - name of variable to store the result in (1 when v1 < v2, 2 when v1 == v2, 3 when v1 > v2)
function gentoo_ver_cmp_out() {
    local v1 v2 out_var_name
    v1=${1}; shift
    v2=${1}; shift
    out_var_name=${1}; shift
    local -n out_ref="${out_var_name}"

    out_ref=0
    _ver_compare "${v1}" "${v2}" || out_ref=${?}
    case ${out_ref} in
        1|2|3)
            return 0
            ;;
        *)
            fail "unexpected return value ${out_ref} from _ver_compare for ${v1} and ${v2}"
            ;;
    esac
}

# 1 - version 1
# 2 - version 2
function gentoo_ver_cmp() {
    local v1 v2 out_var_name
    v1=${1}; shift
    v2=${1}; shift

    local gvc_retval
    gentoo_ver_cmp_out "${v1}" "${v2}" gvc_retval
    return "${gvc_retval}"
}

###
### END GENTOO VER COMP HACKS
###

function ver_min_max() {
    local min_var_name max_var_name
    min_var_name=${1}; shift
    local -n min_ref="${min_var_name}"
    max_var_name=${1}; shift
    local -n max_ref="${max_var_name}"

    local min max v
    min=''
    max=''
    for v; do
        if [[ -z ${min} ]] || gentoo_ver_test "${v}" -lt "${min}"; then
            min=${v}
        fi
        if [[ -z ${max} ]] || gentoo_ver_test "${v}" -gt "${max}"; then
            max=${v}
        fi
    done
    # shellcheck disable=SC2034 # it's a reference to external variable
    min_ref="${min}"
    # shellcheck disable=SC2034 # it's a reference to external variable
    max_ref="${max}"
}

# 1 - package
# 2 - name of the package info mvm for profile 1
# 3 - name of the package info mvm for profile 2
# 4 - name of the pkg to slots to version mvm
# 5 - name of the pkg to all slots mvm
function consistency_check_for_package() {
    local pkg pi1_pimap_mvm_var_name pi2_pimap_mvm_var_name pkg_slot_verminmax_map_mvm_var_name pkg_slots_set_mvm_var_name
    pkg=${1}; shift
    pi1_pimap_mvm_var_name=${1}; shift
    pi2_pimap_mvm_var_name=${1}; shift
    pkg_slot_verminmax_map_mvm_var_name=${1}; shift
    pkg_slots_set_mvm_var_name=${1}; shift

    local ccfp_slot_version1_map_var_name ccfp_slot_version2_map_var_name
    mvm_get "${pi1_pimap_mvm_var_name}" "${pkg}" ccfp_slot_version1_map_var_name
    mvm_get "${pi2_pimap_mvm_var_name}" "${pkg}" ccfp_slot_version2_map_var_name

    local -A empty_map
    empty_map=()

    local -n slot_version1_map="${ccfp_slot_version1_map_var_name:-empty_map}"
    local -n slot_version2_map="${ccfp_slot_version2_map_var_name:-empty_map}"

    local ccfp_slots_set_var_name
    mvm_get "${pkg_slots_set_mvm_var_name}" "${pkg}" ccfp_slots_set_var_name
    local -n slots_set_ref="${ccfp_slots_set_var_name}"

    local -a profile_1_slots profile_2_slots common_slots
    profile_1_slots=()
    profile_2_slots=()
    common_slots=()

    local ccfp_profile_1 ccfp_profile_2
    pkginfo_profile "${pi1_pimap_mvm_var_name}" ccfp_profile_1
    pkginfo_profile "${pi2_pimap_mvm_var_name}" ccfp_profile_2

    local s v1 v2 ccfp_min ccfp_max mm
    for s in "${!slots_set_ref[@]}"; do
        v1=${slot_version1_map["${s}"]:-}
        v2=${slot_version2_map["${s}"]:-}

        if [[ -n ${v1} ]] && [[ -n ${v2} ]]; then
            common_slots+=( "${s}" )
            if [[ ${v1} != "${v2}" ]]; then
                pkg_warn \
                    "- version mismatch:" \
                    "  - package ${pkg}" \
                    "  - slot ${s}" \
                    "  - profile 1: ${ccfp_profile_1}" \
                    "    - version: ${v1}" \
                    "  - profile 1: ${ccfp_profile_2}" \
                    "    - version: ${v2}"
            fi
            ver_min_max ccfp_min ccfp_max "${v1}" "${v2}"
            mm="${ccfp_min}:${ccfp_max}"
        elif [[ -n ${v1} ]]; then
            # only side1 has the slot
            profile_1_slots+=( "${s}" )
            mm="${v1}:${v1}"
        elif [[ -n ${v2} ]]; then
            # only side 2 has the slot
            profile_2_slots+=( "${s}" )
            mm="${v2}:${v2}"
        else
            continue
        fi

        mvm_add "${pkg_slot_verminmax_map_mvm_var_name}" "${pkg}" "${s}" "${mm}"
    done
    if [[ ${#common_slots[@]} -gt 0 ]]; then
        if [[ ${#profile_1_slots[@]} -gt 0 ]] || [[ ${#profile_2_slots[@]} -gt 0 ]]; then
            pkg_warn \
                "- suspicious:" \
                "  - package ${pkg}" \
                "  - profile 1: ${ccfp_profile_1}" \
                "  - profile 2: ${ccfp_profile_2}" \
                "  - common slots: ${common_slots[*]}" \
                "  - slots only in profile 1: ${profile_1_slots[*]}" \
                "  - slots only in profile 2: ${profile_2_slots[*]}" \
                "  - what: there are slots that exist only on one profile while both profiles also have some common slots"
        fi
    fi
}

# consistency checks between:
# not yet: amd64 sdk <-> arm64 sdk
# amd64 sdk <-> amd64 board
# not yet: arm64 sdk <-> arm64 board
# amd64 board <-> arm64 board
function consistency_checks() {
    local which all_pkgs_var_name pkg_slots_set_mvm_var_name pkg_slot_verminmax_mvm_var_name
    which=${1}; shift
    all_pkgs_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n all_pkgs_ref="${all_pkgs_var_name}"
    pkg_slots_set_mvm_var_name=${1}; shift
    pkg_slot_verminmax_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local cc_pimap_mvm_1_var_name cc_pimap_mvm_2_var_name pkg

    # amd64 sdk <-> amd64 board
    pkginfo_name "${which}" amd64 "${SDK_PKGS}" cc_pimap_mvm_1_var_name
    pkginfo_name "${which}" amd64 "${BOARD_PKGS}" cc_pimap_mvm_2_var_name
    mvm_declare cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm mvm_mvc_map
    for pkg in "${all_pkgs_ref[@]}"; do
        consistency_check_for_package "${pkg}" "${cc_pimap_mvm_1_var_name}" "${cc_pimap_mvm_2_var_name}" cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm "${pkg_slots_set_mvm_var_name}"
    done

    # amd64 board <-> arm64 board
    pkginfo_name "${which}" amd64 "${BOARD_PKGS}" cc_pimap_mvm_1_var_name
    pkginfo_name "${which}" arm64 "${BOARD_PKGS}" cc_pimap_mvm_2_var_name
    mvm_declare cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm mvm_mvc_map
    for pkg in "${all_pkgs_ref[@]}"; do
        consistency_check_for_package "${pkg}" "${cc_pimap_mvm_1_var_name}" "${cc_pimap_mvm_2_var_name}" cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm "${pkg_slots_set_mvm_var_name}"
    done

    local cc_slot_verminmax1_map_var_name cc_slot_verminmax2_map_var_name
    local cc_slots_set_var_name s verminmax1 verminmax2 cc_min cc_max verminmax
    local -A empty_map
    # shellcheck disable=SC2034 # used indirectly below
    empty_map=()
    for pkg in "${all_pkgs_ref[@]}"; do
        mvm_get cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm "${pkg}" cc_slot_verminmax1_map_var_name
        mvm_get cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm "${pkg}" cc_slot_verminmax2_map_var_name
        mvm_get "${pkg_slots_set_mvm_var_name}" "${pkg}" cc_slots_set_var_name
        local -n slot_verminmax1_map_ref="${cc_slot_verminmax1_map_var_name:-empty_map}"
        local -n slot_verminmax2_map_ref="${cc_slot_verminmax2_map_var_name:-empty_map}"
        local -n slots_set_ref="${cc_slots_set_var_name}"
        for s in "${!slots_set_ref[@]}"; do
            verminmax1=${slot_verminmax1_map_ref["${s}"]:-}
            verminmax2=${slot_verminmax2_map_ref["${s}"]:-}
            if [[ -n "${verminmax1}" ]] && [[ -n "${verminmax2}" ]]; then
                ver_min_max \
                    cc_min cc_max \
                    "${verminmax1%%:*}" "${verminmax1##*:}" "${verminmax2%%:*}" "${verminmax2##*:}"
                verminmax="${cc_min}:${cc_max}"
            elif [[ -n "${verminmax1}" ]]; then
                verminmax="${verminmax1}"
            elif [[ -n "${verminmax2}" ]]; then
                verminmax="${verminmax2}"
            else
                continue
            fi
            mvm_add "${pkg_slot_verminmax_mvm_var_name}" "${pkg}" "${s}" "${verminmax}"
        done
        unset -n slots_set_ref slot_verminmax2_map_ref slot_verminmax1_map_ref
    done
    mvm_unset cc_amd64_arm64_board_pkg_slot_verminmax_map_mvm
    mvm_unset cc_amd64_sdk_board_pkg_slot_verminmax_map_mvm
}

function read_package_sources() {
    local package_sources_map_var_name
    package_sources_map_var_name=${1}; shift
    local -n package_sources_map_ref="${package_sources_map_var_name}"

    local arch which report pkg repo saved_repo
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in sdk-package-repos board-package-repos; do
                while read -r pkg repo; do
                    saved_repo=${package_sources_map_ref["${pkg}"]:-}
                    if [[ -n ${saved_repo} ]]; then
                        if [[ ${saved_repo} != "${repo}" ]]; then
                            pkg_warn \
                                '- different repos used for the package:' \
                                "  - package: ${pkg}" \
                                '  - repos:' \
                                "    - ${saved_repo}" \
                                "    - ${repo}"
                        fi
                    else
                        package_sources_map_ref["${pkg}"]=${repo}
                    fi
                done <"${WORKDIR}/pkg-reports/${which}-${arch}/${report}"
            done
        done
    done
}

function handle_package_changes() {
    local renamed_old_to_new_map_var_name renamed_new_to_old_map_var_name pkg_to_tags_mvm_var_name
    renamed_old_to_new_map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n renamed_old_to_new_map_ref="${renamed_old_to_new_map_var_name}"
    renamed_new_to_old_map_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n renamed_new_to_old_map_ref="${renamed_new_to_old_map_var_name}"
    pkg_to_tags_mvm_var_name=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a hpc_all_pkgs

    mvm_declare hpc_pkg_slots_set_mvm mvm_mvc_set
    read_reports hpc_all_pkgs hpc_pkg_slots_set_mvm

    mvm_declare hpc_old_pkg_slot_verminmax_map_mvm mvm_mvc_map
    mvm_declare hpc_new_pkg_slot_verminmax_map_mvm mvm_mvc_map
    consistency_checks old hpc_all_pkgs hpc_pkg_slots_set_mvm hpc_old_pkg_slot_verminmax_map_mvm
    consistency_checks new hpc_all_pkgs hpc_pkg_slots_set_mvm hpc_new_pkg_slot_verminmax_map_mvm

    unset_report_mvms

    local -A hpc_package_sources_map
    hpc_package_sources_map=()
    read_package_sources hpc_package_sources_map

    mkdir "${REPORTS_DIR}/updates"

    local -a old_pkgs new_pkgs
    old_pkgs=()
    new_pkgs=()

    local pkg other
    for pkg in "${hpc_all_pkgs[@]}"; do
        other=${renamed_old_to_new_map_ref["${pkg}"]:-}
        if [[ -n "${other}" ]]; then
            old_pkgs+=("${pkg}")
            new_pkgs+=("${other}")
            continue
        fi
        other=${renamed_new_to_old_map_ref["${pkg}"]:-}
        if [[ -n "${other}" ]]; then
            continue
        fi
        old_pkgs+=("${pkg}")
        new_pkgs+=("${pkg}")
    done

    local pkg_idx
    pkg_idx=0

    local old_name new_name old_repo new_repo
    local hpc_old_slots_set_var_name hpc_new_slots_set_var_name
    local hpc_old_slot_verminmax_map_var_name hpc_new_slot_verminmax_map_var_name
    local s hpc_old_s hpc_new_s
    local old_verminmax new_verminmax
    local old_version new_version
    local hpc_cmp_result
    local -A hpc_only_old_slots_set hpc_only_new_slots_set hpc_common_slots_set
    local -a lines
    local hpc_update_dir
    while [[ ${pkg_idx} -lt ${#old_pkgs[@]} ]]; do
        old_name=${old_pkgs["${pkg_idx}"]}
        new_name=${new_pkgs["${pkg_idx}"]}
        pkg_idx=$((pkg_idx + 1))
        old_repo=${hpc_package_sources_map["${old_name}"]}
        new_repo=${hpc_package_sources_map["${new_name}"]}
        if [[ ${old_repo} != "${new_repo}" ]]; then
            pkg_warn \
                '- package has moved between repos? unsupported for now' \
                "  - old package and repo: ${old_name} ${old_repo}" \
                "  - new package and repo: ${new_name} ${new_repo}"
            continue
        fi
        if [[ ${new_repo} != 'portage-stable' ]]; then
            # coreos-overlay packages will need a separate handling
            continue
        fi

        mvm_get hpc_pkg_slots_set_mvm "${old_name}" hpc_old_slots_set_var_name
        mvm_get hpc_pkg_slots_set_mvm "${new_name}" hpc_new_slots_set_var_name
        local -n hpc_old_slots_set_ref="${hpc_old_slots_set_var_name}"
        local -n hpc_new_slots_set_ref="${hpc_new_slots_set_var_name}"
        mvm_get hpc_old_pkg_slot_verminmax_map_mvm "${old_name}" hpc_old_slot_verminmax_map_var_name
        mvm_get hpc_new_pkg_slot_verminmax_map_mvm "${new_name}" hpc_new_slot_verminmax_map_var_name
        local -n old_slot_verminmax_map_ref="${hpc_old_slot_verminmax_map_var_name}"
        local -n new_slot_verminmax_map_ref="${hpc_new_slot_verminmax_map_var_name}"
        hpc_only_old_slots_set=()
        hpc_only_new_slots_set=()
        hpc_common_slots_set=()
        sets_split \
            hpc_old_slots_set_ref hpc_new_slots_set_ref \
            hpc_only_old_slots_set hpc_only_new_slots_set hpc_common_slots_set
        for s in "${!hpc_common_slots_set[@]}"; do
            old_verminmax=${old_slot_verminmax_map_ref["${s}"]:-}
            new_verminmax=${new_slot_verminmax_map_ref["${s}"]:-}
            if [[ -z "${old_verminmax}" ]] || [[ -z "${new_verminmax}" ]]; then
                devel_warn \
                    "- no minmax info available for old and/or new:" \
                    "  - old package: ${old_name}" \
                    "    - slot: ${s}" \
                    "    - minmax: ${old_verminmax}" \
                    "  - new package: ${new_name}" \
                    "    - slot: ${s}" \
                    "    - minmax: ${new_verminmax}"
                continue
            fi
            update_dir "${new_name}" "${s}" "${s}" hpc_update_dir
            mkdir -p "${hpc_update_dir}"
            old_version=${old_verminmax%%:*}
            new_version=${new_verminmax##*:}
            gentoo_ver_cmp_out "${new_version}" "${old_version}" hpc_cmp_result
            case ${hpc_cmp_result} in
                "${GV_GT}")
                    handle_pkg_update "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}" "${new_version}"
                    ;;
                "${GV_EQ}")
                    handle_pkg_as_is "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}"
                    ;;
                "${GV_LT}")
                    handle_pkg_downgrade "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${s}" "${s}" "${old_version}" "${new_version}"
                    ;;
            esac
        done
        if [[ ${#hpc_only_old_slots_set[@]} -eq 1 ]] && [[ ${#hpc_only_new_slots_set[@]} -eq 1 ]]; then
            get_nth_from_set 0 hpc_only_old_slots_set hpc_old_s
            old_verminmax=${old_slot_verminmax_map_ref["${hpc_old_s}"]:-}
            get_nth_from_set 0 hpc_only_new_slots_set hpc_new_s
            new_verminmax=${new_slot_verminmax_map_ref["${hpc_new_s}"]:-}
            if [[ -z "${old_verminmax}" ]] || [[ -z "${new_verminmax}" ]]; then
                devel_warn \
                    "- no verminmax info available for old and/or new:" \
                    "  - old package: ${old_name}" \
                    "    - slot: ${hpc_old_s}" \
                    "    - minmax: ${old_verminmax}" \
                    "  - new package: ${new_name}" \
                    "    - slot: ${hpc_new_s}" \
                    "    - minmax: ${new_verminmax}"
                continue
            fi
            update_dir "${new_name}" "${hpc_old_s}" "${hpc_new_s}" hpc_update_dir
            mkdir -p "${hpc_update_dir}"
            old_version=${old_verminmax%%:*}
            new_version=${new_verminmax##*:}
            gentoo_ver_cmp_out "${new_version}" "${old_version}" hpc_cmp_result
            case ${hpc_cmp_result} in
                "${GV_GT}")
                    handle_pkg_update "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}" "${new_version}"
                    ;;
                "${GV_EQ}")
                    handle_pkg_as_is "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}"
                    ;;
                "${GV_LT}")
                    handle_pkg_downgrade "${pkg_to_tags_mvm_var_name}" "${old_name}" "${new_name}" "${hpc_old_s}" "${hpc_new_s}" "${old_version}" "${new_version}"
                    ;;
            esac
        elif [[ ${#hpc_only_old_slots_set[@]} -gt 0 ]] || [[ ${#hpc_only_new_slots_set[@]} -gt 0 ]]; then
            lines=(
                '- handle package update:'
                '  - old package name:'
                "    - name: ${old_name}"
                '    - slots:'
            )
            for s in "${!hpc_old_slots_set_ref[@]}"; do
                old_verminmax=${old_slot_verminmax_map_ref["${s}"]:-}
                lines+=("      - ${s}, minmax: ${old_verminmax}")
            done
            lines+=(
                '  - new package name:'
                "    - name: ${new_name}"
                '    - slots:'
            )
            for s in "${!hpc_new_slots_set_ref[@]}"; do
                new_verminmax=${new_slot_verminmax_map_ref["${s}"]:-}
                lines+=("      - ${s}, minmax: ${new_verminmax}")
            done
            manual "${lines[@]}"
        fi
        unset -n new_slot_verminmax_map_ref old_slot_verminmax_map_ref hpc_new_slots_set_ref hpc_old_slots_set_ref
    done

    mvm_unset hpc_new_pkg_slot_verminmax_mvm
    mvm_unset hpc_old_pkg_slot_verminmax_mvm
    mvm_unset hpc_pkg_slots_set_mvm
}

function get_nth_from_set() {
    local idx set_var_name return_var_name
    idx=${1}; shift
    set_var_name=${1}; shift
    # shellcheck disable=SC2178 # shellcheck doesn't grok references to arrays
    local -n set_ref="${set_var_name}"
    return_var_name=${1}; shift
    local -n return_ref="${return_var_name}"

    local iter item
    iter=0
    for item in "${!set_ref[@]}"; do
        if [[ ${iter} -eq ${idx} ]]; then
            return_ref=${item}
            return 0
        fi
        iter=$((iter + 1))
    done
    # shellcheck disable=SC2034 # it's a reference to external variable
    return_ref=''
}

function sets_split() {
    local first_set_var_name second_set_var_name only_in_first_set_var_name only_in_second_set_var_name common_set_var_name
    first_set_var_name=${1}; shift
    local -n first_set_ref="${first_set_var_name}"
    second_set_var_name=${1}; shift
    local -n second_set_ref="${second_set_var_name}"
    only_in_first_set_var_name=${1}; shift
    local -n only_in_first_set_ref="${only_in_first_set_var_name}"
    only_in_second_set_var_name=${1}; shift
    local -n only_in_second_set_ref="${only_in_second_set_var_name}"
    common_set_var_name=${1}; shift
    local -n common_set_ref="${common_set_var_name}"

    only_in_first_set_ref=()
    only_in_second_set_ref=()
    common_set_ref=()

    local item mark

    for item in "${!first_set_ref[@]}"; do
        mark=${second_set_ref["${item}"]:-}
        if [[ -z "${mark}" ]]; then
            # shellcheck disable=SC2034 # it's a reference to external variable
            only_in_first_set_ref["${item}"]=x
        else
            # shellcheck disable=SC2034 # it's a reference to external variable
            common_set_ref["${item}"]=x
        fi
    done

    for item in "${!second_set_ref[@]}"; do
        mark=${first_set_ref["${item}"]:-}
        if [[ -z "${mark}" ]]; then
            # shellcheck disable=SC2034 # it's a reference to external variable
            only_in_second_set_ref["${item}"]=x
        fi
    done
}

function handle_pkg_update() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s old new
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local old_no_r new_no_r
    old_no_r=${old%-r+([0-9])}
    new_no_r=${new%-r+([0-9])}

    local pkg_name
    pkg_name=${new_pkg#/}
    local -a lines
    lines=( "from ${old} to ${new}")
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    fi
    # shellcheck disable=SC2153 # OLD_PORTAGE_STABLE is not a misspelling, it comes from globals file
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${old}" "${new}"
    local hpu_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpu_update_dir
    if [[ ! -s "${hpu_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi
    if gentoo_ver_test "${new_no_r}" -gt "${old_no_r}"; then
        # version bump
        generate_changelog_entry_stub "${pkg_name}" "${new_no_r}"
        lines+=( 'release notes: TODO' )
    fi

    local -a hpu_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${new_pkg}" hpu_tags
    generate_summary_stub "${new_pkg}" "${hpu_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function handle_pkg_as_is() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s v
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    v=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local hpai_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpai_update_dir

    local pkg_name
    pkg_name=${new_pkg#/}
    local -a lines
    lines=( "still at ${v}" )

    local hpai_update_dir_parent
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    else
        # If absolutely nothing has changed, generate no reports and
        # remove the update directory.
        if diff --recursive "${OLD_PORTAGE_STABLE}/${old_pkg}" "${NEW_PORTAGE_STABLE}/${new_pkg}" >/dev/null 2>/dev/null; then
            rmdir "${hpai_update_dir}"
            dirname_out "${hpai_update_dir}" hpai_update_dir_parent
            if [[ -z $(echo "${hpai_update_dir_parent}"/*) ]]; then
                rmdir "${hpai_update_dir_parent}"
            fi
            return 0
        fi
    fi
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${v}" "${v}"
    if [[ ! -s "${hpai_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi

    local -a hpai_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${pkg}" hpai_tags
    generate_summary_stub "${new_pkg}" "${hpai_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function handle_pkg_downgrade() {
    local pkg_to_tags_mvm_var_name old_pkg new_pkg old_s new_s old new
    pkg_to_tags_mvm_var_name=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local old_no_r new_no_r
    old_no_r=${old%-r+([0-9])}
    new_no_r=${new%-r+([0-9])}

    local pkg_name
    pkg_name=${new_pkg#/}
    local -a lines
    lines=( "downgraded from ${old} to ${new}" )
    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        lines+=( "renamed from ${old_pkg}" )
    fi
    generate_ebuild_diff "${OLD_PORTAGE_STABLE}" "${NEW_PORTAGE_STABLE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}" "${old}" "${new}"
    local hpd_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" hpd_update_dir
    if [[ ! -s "${hpd_update_dir}/diff" ]]; then
        lines+=( 'no changes in ebuild' )
    fi
    if gentoo_ver_test "${new_no_r}" -lt "${old_no_r}"; then
        # version bump
        generate_changelog_entry_stub "${pkg_name}" "${new_no_r}"
        lines+=( "release notes: TODO" )
    fi

    local -a hpd_tags
    tags_for_pkg "${pkg_to_tags_mvm_var_name}" "${new_pkg}" hpd_tags
    generate_summary_stub "${new_pkg}" "${hpd_tags[@]}" -- "${lines[@]}"

    generate_package_mention_reports "${NEW_STATE}" "${old_pkg}" "${new_pkg}" "${old_s}" "${new_s}"
}

function tags_for_pkg() {
    local pkg_to_tags_mvm_var_name pkg tags_var_name
    pkg_to_tags_mvm_var_name=${1}; shift
    pkg=${1}; shift
    tags_var_name=${1}; shift
    local -n tags_ref="${tags_var_name}"

    local tfp_tags_var_name
    mvm_get "${pkg_to_tags_mvm_var_name}" "${pkg}" tfp_tags_var_name

    if [[ -z ${tfp_tags_var_name} ]]; then
        tags_ref=()
    else
        local -n tags_in_mvm="${tfp_tags_var_name}"
        # shellcheck disable=SC2034 # it's a reference to external variable
        tags_ref=( "${tags_in_mvm[@]}" )
    fi
}

function generate_changelog_entry_stub() {
    local pkg_name v
    pkg_name=${1}; shift
    v=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    printf '%s %s ([%s](TODO))\n' '-' "${pkg_name}" "${v}" >>"${REPORTS_DIR}/updates/changelog_stubs"
}

function generate_summary_stub() {
    local pkg
    pkg=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a tags
    tags=()
    while [[ ${#} -gt 0 ]]; do
        if [[ ${1} = '--' ]]; then
            shift
            break
        fi
        tags+=( "${1}" )
        shift
    done
    # rest are lines

    {
        printf '%s %s:' '-' "${pkg}"
        printf ' [%s]' "${tags[@]}"
        printf '\n'
        printf '  - %s\n' "${@}"
        printf '\n'
    } >>"${REPORTS_DIR}/updates/summary_stubs"
}

function generate_ebuild_diff() {
    local old_ps new_ps old_pkg new_pkg old_s new_s old new
    old_ps=${1}; shift
    new_ps=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    old=${1}; shift
    new=${1}; shift

    local old_pkg_name new_pkg_name
    old_pkg_name=${old_pkg#*/}
    new_pkg_name=${new_pkg#*/}

    local old_path new_path
    old_path="${old_ps}/${old_pkg}/${old_pkg_name}-${old}.ebuild"
    new_path="${new_ps}/${new_pkg}/${new_pkg_name}-${new}.ebuild"

    local ged_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" ged_update_dir
    xdiff "${old_path}" "${new_path}" >"${ged_update_dir}/diff"
}

function generate_package_mention_reports() {
    local scripts old_pkg new_pkg old_s new_s
    scripts=${1}; shift
    old_pkg=${1}; shift
    new_pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift

    local gpr_update_dir
    update_dir "${new_pkg}" "${old_s}" "${new_s}" gpr_update_dir

    generate_mention_report_for_package "${scripts}" "${new_pkg}" >"${gpr_update_dir}/occurences"

    if [[ ${old_pkg} != "${new_pkg}" ]]; then
        generate_mention_report_for_package "${scripts}" "${old_pkg}" >"${gpr_update_dir}/occurences-for-old-name"
    fi
}

function generate_mention_report_for_package() {
    local scripts pkg
    scripts=${1}; shift
    pkg=${1}; shift

    local ps co
    ps='sdk_container/src/third_party/portage-stable'
    co='sdk_container/src/third_party/coreos-overlay'

    yell "${pkg} in overlay profiles"
    grep_pkg "${scripts}" "${pkg}" "${co}/profiles"

    yell "${pkg} in gentoo profiles"
    grep_pkg "${scripts}" "${pkg}" "${ps}/profiles"

    # shellcheck disable=SC2164 # we use set -e, so the script will exit if it fails
    pushd "${scripts}/${co}" >/dev/null

    yell "${pkg} in env overrides"
    cat_entries "coreos/config/env/${pkg}"@(|-+([0-9])*)

    yell "${pkg} in user patches"
    for dir in "coreos/user-patches/${pkg}"@(|-+([0-9])*); do
        echo "BEGIN DIRECTORY: ${dir}"
        cat_entries "${dir}"/*
        echo "END DIRECTORY: ${dir}"
    done

    # shellcheck disable=SC2164 # we use set -e, so the script will exit if it fails
    popd

    yell "${pkg} in overlay (outside profiles)"
    grep_pkg "${scripts}" "${pkg}" "${ps}" ":(exclude)${ps}/profiles"

    yell "${pkg} in gentoo (outside profiles)"
    grep_pkg "${scripts}" "${pkg}" "${co}" ":(exclude)${co}/profiles"

    yell "${pkg} in scripts"
    grep_pkg "${scripts}" "${pkg}" ":(exclude)${ps}/profiles" ":(exclude)${co}/profiles"
}

function update_dir() {
    local pkg old_s new_s dir_var_name
    pkg=${1}; shift
    old_s=${1}; shift
    new_s=${1}; shift
    dir_var_name=${1}; shift
    local -n dir_ref="${dir_var_name}"

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    # slots may have slashes in them - replace them with "-slash-"
    local slot_dir
    if [[ ${old_s} = "${new_s}" ]]; then
        slot_dir="${old_s//\//-slash-}"
    else
        slot_dir="${old_s//\//-slash-}-to-${new_s//\//-slash-}"
    fi
    # shellcheck disable=SC2034 # it's a reference to external variable
    dir_ref="${REPORTS_DIR}/updates/${pkg}/${slot_dir}"
}

function grep_pkg() {
    local scripts pkg
    scripts=${1}; shift
    pkg=${1}; shift
    # rest are directories

    git -C "${scripts}" grep "${pkg}"'\(-[0-9]\|[^a-bA-Z0-9-]\|$\)' -- "${@}" || :
}

function cat_entries() {
    for entry; do
        echo "BEGIN ENTRY: ${entry}"
        cat "${entry}"
        echo "END ENTRY: ${entry}"
    done
}

function handle_gentoo_sync() {
    local non_package_updates_set_var_name renamed_old_to_new_map_var_name renamed_new_to_old_map_var_name pkg_to_tags_mvm_var_name
    non_package_updates_set_var_name=${1}; shift
    local -n non_package_updates_set_ref="${non_package_updates_set_var_name}"
    renamed_old_to_new_map_var_name=${1}; shift
    renamed_new_to_old_map_var_name=${1}; shift
    pkg_to_tags_mvm_var_name=${1}; shift

    handle_package_changes "${renamed_old_to_new_map_var_name}" "${renamed_new_to_old_map_var_name}" "${pkg_to_tags_mvm_var_name}"

    local entry
    for entry in "${!non_package_updates_set_ref[@]}"; do
        case "${entry}" in
            eclass/*)
                handle_eclass "${entry}"
                ;;
            profiles)
                handle_profiles
                ;;
            licenses)
                handle_licenses
                ;;
            scripts)
                handle_scripts
                ;;
            metadata)
                fail "not handling metadata updates"
                ;;
            *)
                fail "unknown non-package update for ${entry}"
                ;;
        esac
    done
}

function handle_eclass() {
    local eclass
    eclass=${1}; shift

    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    mkdir -p "${REPORTS_DIR}/updates/${eclass}"
    diff "${OLD_PORTAGE_STABLE}/${eclass}" "${NEW_PORTAGE_STABLE}/${eclass}" >"${REPORTS_DIR}/updates/${eclass}/diff"
}

function handle_profiles() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a files
    files=()
    local arch which report
    for arch in "${ARCHES[@]}"; do
        for which in "${WHICH[@]}"; do
            for report in sdk-profiles board-profiles; do
                files+=("${WORKDIR}/pkg-reports/${which}-${arch}/${report}")
            done
        done
    done
    local -A profile_dirs_set
    profile_dirs_set=()

    local line
    while read -r line; do
        profile_dirs_set["${line}"]=x
    done < <(xgrep --no-filename '^portage-stable:' "${files[@]}" | cut -d: -f2-)

    local -a diff_opts
    diff_opts=(
        --recursive
        --unified
        --new-file  # treat absent files as empty
    )

    local out_dir
    out_dir="${REPORTS_DIR}/updates/profiles"
    mkdir -p "${out_dir}"

    xdiff "${diff_opts[@]}" \
         "${OLD_PORTAGE_STABLE}/profiles" "${NEW_PORTAGE_STABLE}/profiles" >"${out_dir}/full-diff"

    local relevant
    relevant=''
    local -a relevant_lines possibly_irrelevant_files
    relevant_lines=()
    possibly_irrelevant_files=()
    local path dir mark
    while read -r line; do
        if [[ ${line} = "diff ${diff_opts[*]} "* ]]; then
            path=${line##*"${NEW_PORTAGE_STABLE}/profiles/"}
            dirname_out "${path}" dir
            relevant=''
            mark=${profile_dirs_set["${dir}"]}
            if [[ -n "${mark}" ]]; then
                relevant=x
            else
                case ${dir} in
                    .|desc|desc/*|updates|updates/*)
                        relevant=x
                        ;;
                esac
            fi
            if [[ -z ${relevant} ]]; then
                possibly_irrelevant_files+=( "profiles/${path}" )
            fi
        fi
        if [[ -n ${relevant} ]]; then
            relevant_lines+=( "${line}" )
        fi
    done
    lines_to_file_truncate "${out_dir}/relevant-diff" "${relevant_lines[@]}"
    lines_to_file_truncate "${out_dir}/possibly-irrelevant-files" "${possibly_irrelevant_files[@]}"
}

function handle_licenses() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local -a dropped added changed
    dropped=()
    added=()
    changed=()

    local line
    # Lines are:
    #
    # Only in <PORTAGE_STABLE_X>/licenses: BSL-1.1
    #
    # or
    #
    # Files <PORTAGE_STABLE_1>/licenses/BSL-1.1 and <PORTAGE_STABLE_2>/licenses/BSL-1.1 differ
    while read -r line; do
        if [[ ${line} = 'Only in '* ]]; then
            # shellcheck disable=SC2153 # OLD_STATE is not a misspelling, it comes from globals file
            if [[ ${line} = *"${OLD_STATE}"* ]]; then
                dropped+=( "${line##*:}" )
            elif [[ ${line} = *"${NEW_STATE}"* ]]; then
                added+=( "${line##*:}" )
            else
                devel_warn "- unhandled license change: ${line}"
            fi
        elif [[ ${line} = 'Files '*' differ' ]]; then
            line=${line##"Files ${OLD_PORTAGE_STABLE}/licenses/"}
            line=${line%% *}
            changed+=( "${line}" )
        else
            devel_warn \
                '- unhandled diff --brief line:' \
                "  - ${line}"
        fi
    done < <(xdiff --brief --recursive "${OLD_PORTAGE_STABLE}/licenses" "${NEW_PORTAGE_STABLE}/licenses")

    local out_dir
    out_dir="${REPORTS_DIR}/updates/licenses"
    mkdir -p "${out_dir}"

    lines_to_file_truncate \
        "${out_dir}/brief-diff" \
        '- removed:' \
        "${dropped[@]/#/  - }" \
        '- added:' \
        "${added[@]/#/  - }" \
        '- modified:' |
        "${changed[@]/#/  - }"
    truncate --size=0 "${out_dir}/mod-diff"

    local c
    for c in "${changed[@]}"; do
        xdiff "${OLD_PORTAGE_STABLE}/licenses/${c}" "${NEW_PORTAGE_STABLE}/licenses/${c}" >>"${out_dir}/mod-diff"
    done
}

function handle_scripts() {
    # shellcheck disable=SC1091 # generated file
    source "${WORKDIR}/globals"

    local out_dir
    out_dir="${REPORTS_DIR}/updates/scripts"
    mkdir -p "${out_dir}"

    xdiff --unified --recursive "${OLD_PORTAGE_STABLE}/scripts" "${NEW_PORTAGE_STABLE}/scripts" >"${out_dir}"
}

function xdiff() {
    diff "${@}" || :
}

function xgrep() {
    grep "${@}" || :
}
